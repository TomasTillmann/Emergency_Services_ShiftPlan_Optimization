\chapter{Řešení optimalizační úlohy}\label{chap:reseniOptUloh}

V této kapitole vyzkoušíme různé metody, které můžeme pro nalezení optimálního plánu pohotovostní služby použít.

\section{Dynamické programování}\label{kap:dynamicProgram}

\textit{Dynamické programování} je technika řešení problému, která si průběžně ukládá řešení menších podúloh a pomocí rekurzivního vztahu menší podúlohy s větší,
definovaného \textit{rekurzivním vztahem}, řeší větší podúlohy efektivněji, až po vyřešení původní úlohy. 
Průběžnému ukládání výsledků podúloh se říká \textit{memoizace}.
Díky této memoizaci dynamické programování neprohledává prostor řešení duplicitně, a tak je často velmi efektivní metodou pro řešení optimalizačních úloh (\citet{dynamic}).

Triviálním příkladem využití dynamického programování je výpočet $n$-tého \textit{Fibbonaciho čísla}. (\citet{mares}, kap. 12).
Pro nás zajímavějším příkladem využití dynamického programování je řešení úlohy kombinatorické optimalizace \textit{Problému batohu}.

\begin{definice}[Problém batohu]
  Nechť $n$ počet předmětů, které chceme vložit do batohu s kapacitou $c$.
  Každý předmět $i$ má výdělek $p_i$ a váhu $w_i$. Problém batohu pak je,

  \begin{alignat*}{2}
    &\normalfont \text{maximalizuj} \hspace{30pt} &z = \sum_{i=1}^n p_i x_i, \\
    \\
    &\normalfont \text{splňující}   \hspace{30pt} &\sum_{i = 1}^{n} w_i x_i \leq c,
  \end{alignat*}
  \\
  kde $x_i = 1$, pokud předmět $i$ je v batohu, jinak $0$.
  \\
\end{definice}

Existuje $2^n$ možností, které předměty vložíme do batohu. Naivní řešení prohledání všech možností tak běží v čase $\mathcal{O} (2^n)$.
Avšak pomocí dynamického programování lze vyřešit problém batohu v \textit{pseudopolynomiálním} čase $\mathcal{O}(nc)$,
což pro velká $n$ a konstatní $c$ je až exponenciálním zlepšením.

Bellmanovy rovnice vyjadřující rekurzivní vztahy vypadají následovně,

\begin{definice}[Rekurzivní vztah pro problém batohu]\label{rov:KPrekurz}
  \begin{align*}
    m_{i, c'} &= m_{i - 1, c'} \text{ pokud } w_i > c', \\
    m_{i, c'} &= \max (m_{i - 1, c'}, m_{i - 1, c' - w_i} + p_i) \text{ pokud } w_i \leq c',
  \end{align*}
  \\
  pro $0 \leq c' \leq c$ aktuální uvažovaná kapacita batohu.
\end{definice}

Rekurzivní vztah \ref{rov:KPrekurz} nám pouze říká, že ze znalostí optimálního výběru předmětů podpbroblému $m_{i-1, c' - w_i}$ a podproblému $m_{i - 1, c'}$,
umíme v konstantím čase zjistit optimální výběr předmětů pro aktuální problém $c'$, tedy $m_{i, c'}$.
Buď předmět $i$ použijeme při výběru, a tak aktuální optimální výběr je roven $m_{i - 1, c' - w_i} + p_i$,
nebo předmět při výběru nepoužijeme, takže aktuální optimální výběr je optimální výběr podproblému, $m_{i - 1, c'}$. 

\begin{algorithm}[h]
  \begin{algorithmic}[1]
  \Function{KnapsackProblem}{$n$, $c$, $p_i$, $w_i$, $1 \leq i \leq n$}
    \State $m_{i, j}$ \gets 0, $0 \leq i \leq n$, $0 \leq j \leq c$
    \For{$1 \leq i \leq n$}
      \For{$1 \leq j \leq c$}
        \If{$w_i > j$}
          \State $m_{i, j}$ \gets $m_{i - 1, j}$
        \Else
          \State $m_{i, j}$ \gets $\max$ ($m_{i - 1, j}$, $m_{i - 1, j - w_i} + p_i$)
        \EndIf
      \EndFor
    \EndFor
    \State \Return $m_{n,c}$
  \EndFunction
  \end{algorithmic}
  \caption{Problém batohu}
  \label{KP}
\end{algorithm}

Algoritmus \ref{KP} vrací sumu hodnot optimálních předmětů přidaných do batohu.
Jaké konkrétní předměty přispěly do sumy lze snado zjistit zpětným následováním rekurzivního vztahu \ref{rov:KPrekurz}.

Rádi bychom našli nějaký podobný rekurzivní vztah v problému hledání optimálního plánu.
Nalezením rekurzivních vztahů by pak simulace $s$ nebyla černou skříňkou a byla by splněna nutná podmínka \ref{veta:simulaceJakoCernaSkrinka} pro šanci na polynomiální řešení.

\subsection{Prohledávání prostoru plánů tahy}

V předchozí kapitole \ref{kap:dynamicProgram} jsme si ukázali, jak se obecně dynamickým programováním dá 
vyřešit náročná kombinatorická úloha.

V této kapitole budeme zkoumat, jestli existují nějaké rekurzivní vztahy 
\uv{optimálních plánu} na méně incidentech s \uv{optimálními plány} na více incidentech, abychom efektivně vyřešili optimalizační problém nalezení optimálního plánu pohotovostní služby. 

Nalezneme takový rekurzivní vztah \ref{veta:optimalniTahy} a to pomocí prohledávání plánů pomocí \textit{tahů} \ref{df:tah}, konkrétně \textit{optimálních tahů} \ref{df:optimalniTahy}.
Optimálními tahy budeme postupně budovat \textit{plány optimální v ceně} \ref{df:planOptVCene},
podle vhodně zvolených podmnožin množiny incidentů $I$, \textit{seřazených incidentů} \ref{df:INC}.
Věta \ref{veta:dosazitelnostOptimalnimiTahy} dokáže, že takový postup skutečně musí nalézt všechny optimální plány, ale pouze při účelové funkci $q^{\text{Lex}}$.
Také navrhneme algoritmus \ref{alg:rekProhPlanu},
který korektně nalezne všechny takové optimální plány pro množinu $I$, a bude fungovat rychleji než naivní řešení.
Detailní rozebrání složitosti algoritmu popisuje věta \ref{veta:slozitostRek}.

\begin{definice}[Seřazené incidenty]\label{df:INC}
  Nechť množina incidentů 
  \begin{equation*}
    I = \{ i_1, \dots , i_n \} \text{, kde } \forall j, k \in \{ 1, \dots n\} \colon T_I(i_j) \leq T_I(i_k),
  \end{equation*}
  čili incidenty jsou seřazené podle času nastání.
  Definujme množiny incidentů
  \begin{equation*}
    I_0, I_1, \dots, I_n \text{, kde } \forall k \in \{ 0, \dots, n \} \colon I_k = \{ i_1, \dots, i_k \}.
  \end{equation*}

  Incidenty $I_k$ jsou tak incidenty $I_{k-1}$ po odebrání incidentu $i_k$, který se odehrál jako poslední.
\end{definice}

Pomocí seřazených incidentů budeme postupně konstruovat plány optimální v ceně.
Z plánu optimálního v ceně pro $I_{k-1}$ získáme plány optimální v ceně pro $I_k$ pomocí \textit{tahů}, konkrétně nějakých \textit{optimálních tahů}.
\begin{definice}[Tah]\label{df:tah}
  Nadefinujme tah jako funkci $T \colon P_C \rightarrow P_C$.
  Pokud $p' = T(p)$, řekneme, že jsme plán $p'$ získali z $p$ tahem $T$.
\end{definice}

\begin{definice}[Inverzní tah]\label{df:tah}
  Nechť tah $T$. Inverzní tah $T^{-1}$ k tahu $T$ je tah, pro který platí
  \begin{align*}
    T(p) = p' \Leftrightarrow T^{-1}(p') = p.
  \end{align*}
\end{definice}

Můžeme pak nějakou posloupností tahů převést jeden plán na druhý.
\begin{definice}[Posloupnost tahů]
  Posloupností tahů velikosti $n$ rozumíme posloupnost tahů $T_1, T_2, \dots, T_n$.
  Řekneme, že z plánu $p$ získáme plán $p'$ posloupností tahů $T_1, T_2, \dots, T_n$,
  pokud $(T_1 \circ T_2 \circ \dots \circ T_n)(p) = p'$, kde symbol $\circ$ značí binární operaci skládání funkcí,
  kde se první vyhodnotí levá funkce a pak pravá.
\end{definice}

Následující \textit{kanonické tahy} jsou zajímavé z toho důvodu, že vhodnými posloupnostmi vhodných kanonických tahů získáme \textit{optimální tahy},
právě kterými budeme postupně budovat pro množiny incidentů $I_{k-1}$ až $I_k$ plány optimální v ceně. 

\begin{definice}[Kanonické tahy]
  Kanonickými tahy rozumíme tahy
  \begin{enumerate}
    \item
      Alokace záchranného týmu na výjezdovou stanici.

    \item
      Alokace záchranného vozidla na výjezdovou stanici.

    \item
      Prodloužení doby trvání směny již naalokovaného záchranného týmu. 

    \item
      Identita.
  \end{enumerate}

  Formálně,
  \begin{enumerate}
    \item
      kanonický tah alokace týmu $z'$ na výjezdovou stanici je tah $T$, kde
      \begin{align*}
        p_Z'(z) &=
          \begin{cases}
            v \neq v_{\emptyset} & \text{pro tým $z' \in Z \colon p_Z(z') = v_{\emptyset}, v \in V$}, \\
            p_Z(z) & \text{pro $\forall z \in Z \setminus \{ z' \}$},
          \end{cases}
          \\
        p_D'(z) &=
          \begin{cases}
            (d_s, d_l) \in D \colon d_l - d_s > 0 & \text{pro $z'$}, \\
            p_D(z) & \text{pro $\forall z \in Z \setminus \{ z' \}$},
          \end{cases}
          \\
        p_A'(a) &= p_A(a), \forall a \in A,
      \end{align*}

      pro $p_Z, p_D, p_A \in p$ a $p_Z', p_D', p_A' \in p'$, kde $p, p' \in P_C$ a $T(p) = p'$.

    \item
      Kanonický tah alokace záchranného vozidla $a'$ na výjezdovou stanici je tah $T$, kde
      \begin{align*}
        p_Z'(z) &= p_Z(z), \forall z \in Z,
        \\
        p_D'(z) &= p_D(z), \forall z \in Z,
        \\
        p_A'(a) &=
        \begin{cases}
          v \neq v_{\emptyset} & \text{pro záchranné vozidlo $a' \in A \colon p_A(a') = v_{\emptyset}, v \in V$}, \\
          p_A(a) & \text{pro $\forall a \in A \setminus \{ a' \}$},
        \end{cases}
      \end{align*}

      pro $p_Z, p_D, p_A \in p$ a $p_Z', p_D', p_A' \in p'$, kde $p, p' \in P_C$ a $T(p) = p'$.

    \item
      Kanonický tah prodloužení směny týmu $z'$ je tah $T$, kde
      \begin{align*}
        p_Z'(z) &= p_Z(z), \forall z \in Z \\
        p_D'(z) &=
          \begin{cases}
            (d'_s, d'_l) \in D \colon d'_l > d_l \land d'_s = d_s  & \text{pro $z'$} \\
            p_D(z) & \text{pro $\forall z \in Z \setminus \{ z' \}$},
          \end{cases}
          \\
        p_A'(a) &= p_A(a), \forall a \in A,
      \end{align*}

      pro $p_Z, p_D, p_A \in p$ a $p_Z', p_D', p_A' \in p'$, kde $p, p' \in P_C$ a $T(p) = p'$.

    \item
      Kanonický tah posun začátku směny týmu $z'$ je tah $T$, kde
      \begin{align*}
        p_Z'(z) &= p_Z(z), \forall z \in Z \\
        p_D'(z) &=
          \begin{cases}
            (d'_s, d'_l) \in D   & \text{pro $z'$} \\
            p_D(z) & \text{pro $\forall z \in Z \setminus \{ z' \}$},
          \end{cases}
          \\
        p_A'(a) &= p_A(a), \forall a \in A,
      \end{align*}
      pro
      \begin{equation*}
        (d'_s, d'_l) \colon d'_s \in D_S \land d'_l = p_{D_L}(z') \land d'_s < d'_l
      \end{equation*}
      a $p_Z, p_D, p_A \in p$ a $p_Z', p_D', p_A' \in p'$, kde $p, p' \in P_C$ a $T(p) = p'$.

    \item
      Kanonický tah identita je tah $T: p \rightarrow p$.
  \end{enumerate}

\end{definice}

Dále budeme tahy definovat pouze slovně, protože se bude vždy jednat o nějaké posloupnosti kanonických tahů.

Můžou existovat plány $p \in P_C$, na kterých nějaký tah nelze provést, čili $T(p)$ je nedefinované.
Například, pokud bychom plánu chtěli alokovat tým, ale už nejsou žádné k dispozici, nebo už není volná žádná výjezdová stanice podle omezení $C$.
Řekněme, že tah $T$ \textit{lze provést na plánu $p \in P_C$}, pokud $T(p)$ je definováno.

Pomocí tahů můžeme $P_C$ \textit{prohledávat}.
Nechť množina tahů $T$.
Plán $p_2$ \textit{je dosažitelný tahy $T$ z plánu $p_1$}, pokud existuje posloupnost tahů $T_1 \in T, \dots, T_n \in T$ taková, že $(T_1 \circ \dots \circ T_n)(p_1) = p_2$.
Pokud optimální plán $p^* \in P_C$ je nějakými tahy $T_i$ dosažitelný z $p \in P_C$, pak ho můžeme prohledáváním, které začíná v $p$ nalézt.
Pomocí tahů můžeme $P_C$ prohledávat sofistikovaněji, než je jenom všechny procházet, jak jsme dělali v naivním řešení \ref{df:naivniRes}.

Některé plány totiž ani nemá smysl prohledávat, jako například plány, které naalokují záchranáře tak nešikovně, že neodbavují úspěšně žádný incident.
Taková naalokování jenom přispívají do ceny plánu, ale nijak do počtu úspěšně odbavených incidentů.

Dále budeme zkoumat, jaké plány má smysl prohledávat a jakými tahy jsme takové plány schopni nalézt, tedy jsou dosažitelné.
\begin{definice}[Tahy snižující cenu]\label{df:invKanTahy}
  Za tahy snižující cenu rozumíme tahy:
  \begin{enumerate}
    \item
      dealokování týmu,

    \item
      dealokování vozidla,

    \item
      zkrácení doby trvání směny,

    \item
      posun začátku směny na později a zkrácení doby trvání směny.

  \end{enumerate}
\end{definice}

Tahy 1--3 jsou inverzní kanonické tahy alokování týmu, alokování vozidla a prodloužení směny.
Tah 4 lze chápat jako zkrácení směny \uv{zleva}.

\begin{definice}[Plán optimální v ceně]\label{df:planOptVCene}
  Nechť množina incidentů $I$ a plán $p \in P_C \colon s(p, I) = r$.
  Řekneme, že $p$ je optimální v ceně právě tehdy, když
  pro plán $p'$ vzniklý z plánu $p$ provedením libovolného tahu snižujícího cenu platí: 
  \begin{equation*}
    s(p', I) < r.
  \end{equation*}
\end{definice}

Plán optimální v ceně je takový plán, že jakýkoliv pokus o snížení ceny nějakým tahem snižující cenu způsobí, že výsledný plán bude odbavovat méně incidentů.
Následující věta \ref{veta:lexJeOptVCene} objasní, k čemu jsou plány optimální v ceně užitečné.
\begin{veta}[Optimální plán při účelové funkci $q^{\text{Lex}}$ je optimální v ceně]\label{veta:lexJeOptVCene}
  Optimální plán $p^*$ při účelové funkci $q^{\text{Lex}}$ na množině incidentů $I$ je optimální v ceně.
\end{veta}
\begin{dukaz}
  Pro spor předpokládejme, že $p^*$ není optimální v ceně.
  Pak existuje tah snižující cenu $U$ takový, že
  \begin{equation*}
    s(U(p^*), I) = s(p^*, I) \land U(u(p^*)) < u(p^*).
  \end{equation*}
  Plán $U(p^*)$ odbavuje stejně incidentů a zároveň je levnější.
  To je spor s optimalitou $p^*$ pří účelové funkci $q^{\text{Lex}}$.
\end{dukaz}

Z věty \ref{veta:lexJeOptVCene} plyne, že pokud bychom nalezli způsob, kterým budeme schopni prohledávat pouze plány optimální v ceně v množině $P_C$, tak nutně
nalezneme i všechny optimální plány při účelové funkci $q^{\text{Lex}}$.
Následujícím tahům budeme říkat \textit{optimální tahy}, a těmito tahy budeme schopni z prázdného plánu budovat pouze plány optimální v ceně.
Následuje definování jednotlivých optimálních tahů.

\begin{definice}[Tah minimální prodloužení směny týmu]
  Tahem \textit{minimální prodloužení směny týmu} na plánu $p \in P_C$ pro množinu incidentů $I$, rozumíme tah $T$, prodloužení směny týmu a případně alokace vozidla tak, že
  \begin{enumerate}
    \item
      $s(T(p), I) = s(p, I) + 1$,
    \item
      $T(p)$ je optimální v ceně.
    % \item
      % tým $z$ odbavuje $i \in I$ takový, že $p$ incident $i$ neodbavoval.
  \end{enumerate}
\end{definice}

\begin{definice}[Tah minimální alokace týmu]
  Tahem \textit{minimální alokace týmu} na $p \in P_C$ pro množinu incidentů $I$, rozumíme tah $T$, alokace týmu a případně alokace vozidla tak, že
  \begin{enumerate}
    \item
      $s(T(p), I) = s(p, I) + 1$,

    \item
      $T(p)$ je optimální v ceně,

    % \item
      % tým $z$ odbavuje $i \in I$ takový, že $p$ incident $i$ neodbavoval,

    \item
      $T$ alokuje směnu s nejpozdějším možným začátkem směny, aby $T(p)$ stále odbavoval incident $i$. 
  \end{enumerate}
\end{definice}

\begin{definice}[Optimální tahy]\label{df:optimalniTahy}
  Optimálními tahy $T^*$ plánu $p \in P_C$ pro množinu incidentů $I$ rozumíme množinu tahů:
  \begin{enumerate}
  \item
    tah minimální prodloužení směny týmu,
  \item
    tah minimální alokace týmu,
  \item
    tah identita,
  \end{enumerate}
  které lze na plánu $p$ pro množinu $I$ provést.
\end{definice}

Následující věta \ref{veta:optimalniTahy} vše spojí dohromady a poskytne základ pro postup, jak šikovně prohledávat plány pomocí optimálních tahů.
\begin{veta}[O optimálních tazích]\label{veta:optimalniTahy}
  Nechť množiny incidentů $I_0, \dots, I_n$ podle definice \ref{df:INC}.
  Nechť plán optimální v ceně $p_k \in P_C \colon s(p_k, I_k) = r$.
  Pak existuje plán optimální v ceně
  \begin{equation*}
    p_{k-1} \in P_C \colon s(p_{k-1}, I_{k-1}) = r \lor s(p_{k-1}, I_{k-1}) = r - 1
  \end{equation*}
  a optimální tah $T$ takový, že
  \begin{equation*}
    T(p_{k-1}) = p_k,
  \end{equation*}
  pro všechna $k \in \{ 1, \dots, n\}$.
\end{veta}
\begin{dukaz}
  Nechť $\forall k \in \{ 1, \dots, n\}$, $i_1, \dots, i_k$ incidenty $I_k$ a $i'_1, \dots, i'_r$ incidenty, které odbaví $p_k$.
  Rozlišme dvě situace, které mohou nastat:
  \begin{enumerate}
    \item
      $i'_r \neq i_k$,

    \item
      $i'_r = i_k$.
  \end{enumerate}
  V prvním případě je hledaný $p_{k-1}$ právě $p_k$ a tah $T$ identita.
  Platí $s(p_k, I_{k-1}) = r$, protože $p_k$ neodbaví poslední incident $i_k \not \in I_{k-1}$ a simulace incidenty prochází postupně \ref{simulaceAlgo},
  takže výpočet simulace na plánu $p_{k}$ a na množinách $I_k$ i $I_{k-1}$ je do $i_{k-1}$ incidentu totožný.
  Zároveň $p_k$ je optimální v ceně na $I_k$ a jelikož $p_k$ odbavuje stejné incidenty na $I_{k-1}$, tak je optimální v ceně i na $I_{k-1}$.

  V druhém případě, je poslední incident $i_k = i'_r$ plánem $p_k$ odbaven.
  Z toho důvodu $p_k$ na množině inidentů $I_{k-1}$ odbavuje incidenty $i'_1, \dots, i'_{r-1}$, o jeden méně -- opět, simulace incidenty prochází postupně \ref{simulaceAlgo}.
  Platí tak, že $s(p_k, I_{k-1}) = r - 1$. Plán $p_k$ však nemusí být optimální v ceně, takže $T$ nemusí být tah identita jak pro případ $i'_k = i'_r$. 

  Libovolné snížení ceny lze jistě docílit nějakou posloupností tahů snižujících cenu.
  Chceme nalézt vhodnou posloupnost takovou, že díky ní zkounstruujeme optimální tah.

  Uvažme tým záchranářů $z$, který odbavoval incident $i_k$.
  Pro tým $z$ pak pro spuštění simulace na plánu $p_k$ na množině incidentů $I_{k-1}$ platí:
  \begin{enumerate}
    \item
      Tým $z$ odbavuje jenom $i_k$, pak je v plánu $p_k$ naalokován zbytečně. O odbavení všech ostatních $r-1$ incidentů se postarájí ostatní týmy.

    \item
      Tým $z$ odbavuje i jiné incidenty $I_z$, ale jelikož
      \begin{equation*}
        \forall i_z \in I_z \colon T_I(i_z) < T_I(i_k),
      \end{equation*}
      tak $z$ odbavuje $i_k$ až po odbavení všech incidentů $I_z$.
      Aby $i_k$ úspěšně odbavil, tudiž může mít delší směnu, než by měl, pro odbavení $I_z$.
  \end{enumerate}
  V obou případech ještě může být zbytečně naalokováno vozidlo, které $z$ používal pro odbavení $i_k$.
  Žádná jiná možnost nemůže nastat.

  Z pozorování plyne, že vždy existuje dvojice tahů $T_2^{-1}$ a $T_2^{-1}$, kde pro jejich složení $T^{-1} = T_2^{-1} \circ T_2^{-1}$,
  platí, že $T^{-1}(p_k)$ je optimální v ceně a $s(T^{-1}(p_k), I_{k-1}) = r - 1$:
  \begin{enumerate}
  \item
    dealokace týmu a dealokace vozidla, 
  \item
    maximální zkrácení směny týmu a dealokace vozidla,
  \item
    dealokace týmu a identita,
  \item
    maximální zkrácení směny týmu a identita,
  \item
    identita a identita.
  \end{enumerate}
  Maximálním zkrácením směny týmu $z$ myslíme tah zkrácení směny $T$, že
  \begin{equation}\label{eq:rrr}
    s(T(p_k), I_{k-1}) = r - 1
  \end{equation}
  a směna už týmu $z$ nelze zkrátit více, aby platilo \ref{eq:rrr}.
  Ukázali jsme existenci $T^{-1}$ v obou případech. Nechť
  \begin{equation*}
    T = T_1 \circ T_2,
  \end{equation*}
  kde $T_1$ a $T_2$ jsou inverzními tahy k $T_1^{-1}$ a $T_2^{-1}$.
  Možnými tahy $T$ tak jsou:
  \begin{enumerate}
  \item
    minimální alokace týmu a alokace vozidla, 
  \item
    minimální prodloužení týmu a alokace vozidla,
  \item
    minimální alokace týmu a identita,
  \item
    minimální prodloužení směny týmu a identita,
  \item
    identita a identita.
  \end{enumerate}

  Alokace týmu jsou minimální, protože $p_k$ byl plán optimální v ceně.
  Tah $T$ je optimální tah pro každý případ.
\end{dukaz}

\begin{veta}[O dosažitelnosti optimálního plánu optimálními tahy]\label{veta:dosazitelnostOptimalnimiTahy}
  Optimální plán $p^* \in P_C$ na množině incidentů $I$ při účelové funkci $q^{\text{Lex}}$ je z $p_0$ dosažitelný nějakou posloupností optimálních tahů $T_1 \circ \dots T_{|I|-1}$.
\end{veta}
\begin{dukaz}
  Nechť $n = |I|$.
  Plán $p^*$ odbavuje $r = s(p^*, I)$ incidentů.
  Z věty \ref{veta:lexJeOptVCene} je $p^*$ optimální v ceně.
  Existují pro něj podle věty \ref{veta:optimalniTahy} optimální tah $T_{n-1}$ a plán $p_{n-1}$ takové, že
  \begin{equation*}
    p_n = T_{n-1}(p_{n-1})
  \end{equation*}
  a $p_{n-1}$ odbavuje stejně nebo o jeden méně incidentů na $I_{n-1}$ než $r$.
  Opět z věty \ref{veta:optimalniTahy} pro něj existují $p_{n-2}, T_{n-2} \colon p_{n-1} = T_{n-2}(p_{n-2})$, atd.\

  Takovou konstrukcí sestrojíme $p_{k}, T_{k}, \forall k \in \{ 0, \dots, n-1 \}$. 
  Plán $p_0$ je z věty \ref{veta:optimalniTahy} plán na prázdné množině odbavující buď jeden nebo nula incidentů, optimální v ceně.
  Pro prázdnou množinu incidentů jakýkoliv jiný plán než prázdný plán $p_0$ není optimální v ceně.
  Tudiž plán $p_0$ je prázdný plán.
  Tahy $T_k$ jsou optimální tahy, takže se jedná o hledanou posloupnost takovou, že
  \begin{equation*}
    p^* = (T_0 \circ T_1 \circ \dots \circ T_{n-1})(p_0).
  \end{equation*}
\end{dukaz}

\subsection{Rekurzivní prohledávání stromu optimálních tahů}

Věta \ref{veta:dosazitelnostOptimalnimiTahy} nám dává návod, jak plány $P_C$ z $p_0$ prohledávat optimálními tahy $T_1 \in T^*_1, \dots , T_{|I| - 1} \in T^*_{|I|-1}$.

\begin{algorithm}[H]
  \begin{algorithmic}[1]
  \Function{OptimalMovesSearch}{$p$, $I_k$, $h$}
    \If{$k = h$}
      \State \Return $\{ p \}$
    \ElsIf{$\text{Cache}[k, p] \text{ je vyplněna}$}
      \State \Return $\text{Cache}[k, p]$
    \EndIf
    \State $T^*_k$ \gets optimální tahy \ref{df:optimalniTahy}
    \State $P^*$ \gets $\emptyset$
    \For{$T^* \in T^*_k$}
      \State $P'^*$ \gets \text{OptimalMovesSearch($T^*(p)$, $I_{k+1}$, $h$)}
      \State $p^*$ \gets libovolný z $P^*$
      \State $p'^*$ \gets libovolný z $P'^*$
      \If{$P^* = \emptyset$}
        \State $P^*$ \gets $P'^*$ 
      \ElsIf{$q^{\text{Lex}}(p^*) = q^{\text{Lex}}(p'^*)$}
        \State $P^*$ sjednoť s $P'^*$
      \ElsIf{$q^{\text{Lex}}(p^*) < q^{\text{Lex}}(p'^*)$}
        \State $P^*$ nahraď $P'^*$
      \EndIf
    \EndFor
    \State $\text{Cache}[k, p]$ \gets $P^*$
    \State \Return $P^*$
  \EndFunction
  \end{algorithmic}
  \caption{Rekurzivní prohledávání prostoru plánů optimálními tahy}
  \label{alg:rekProhPlanu}
\end{algorithm}

Pro zjištění všech optimálních plánu $P^*$ na množině incidentů $I$ algoritmus \ref{alg:rekProhPlanu} zavoláme: $P^* = $ OptimalMovesSearch($p_0$, $I_1$, $|I|$).

\begin{veta}[Korektnost a úplnost algoritmu \ref{alg:rekProhPlanu}]\label{}
  Algoritmus rekurzivního prohledávání prostoru plánů optimálními tahy \ref{alg:rekProhPlanu} nalezne všechny optimální plány $P^* \in P_C$ při účelové funkci $q^{\text{Lex}}$.
\end{veta}
\begin{dukaz}
  Z věty \ref{veta:dosazitelnostOptimalnimiTahy} víme, že $p^*$ je dosažitelný nějakou posloupností optimálních tahů. 
  V algoritmu v kroku 5 množina $T^*_k$ obsahuje všechny optimální tahy, které lze provést na plánu $p$ na množině $I_k$.
  V kroku 8 se rekurzivně zavoláme na každý $T^*(p), T^* \in T^*_k$.
  Algoritmus tudiž prohledá každou posloupnost optimálních tahů, takže určitě i všechny takové, kterými se získá libovolný optimální plán $p \in P^*$ \ref{veta:dosazitelnostOptimalnimiTahy}.
  Algoritmus je úplný.

  V krocích 11--17 z plánů, které se vrátí rekurzí, vybíráme pouze ty optimální vůči $q^{\text{Lex}}$.
  Vybíráme tak ze všech plánů, které jsou dosažitelné nějakou posloupností optimálních tahů ty optimální.
  Cache je používána korektně.
  Algoritmus je korektní.
\end{dukaz}

Omezili jsme se na použití účelové funkce $q^{\text{Lex}}$, protože potřebujeme, aby optimální plán podle účelové funkce $q$ byl zároveň optimální v ceně.
Tento předpoklad optimální plán při $q^{\text{Lex}}$ splňuje \ref{veta:lexJeOptVCene}.
Aby byl algoritmus korektní, mohli bychom použít jakoukoliv jinou účelovou funkci $q$, pro kterou optimální plán při $q$ je zároveň optimálním v ceně.
Podle věty \ref{veta:dosazitelnostOptimalnimiTahy} bude dosažitelný optimálními tahy, takže jej algoritmus navštíví.

\begin{veta}[Odhad počtu optimálních tahů pro plán optimální v ceně]\label{veta:pocetOptTahu}
  Nechť plán optimální v ceně $p \in P_C$ a nechť optimální tahy $T$, které lze provést na plánu $p$ na množině $I$.
  Pak
  \begin{equation*}
    1 \leq |T| \leq Z_n + 1.
  \end{equation*}
\end{veta}
\begin{dukaz}
  Optimální tahy jsou minimální alokace týmu, minimální prodloužení směny týmu a identita.
  Počet minimálních alokací je nanejvýš
  \begin{alignat*}{2}
    Z_1, \quad && \hspace{15pt} \text{počet nenaalokovaných vozidel.}
  \end{alignat*}
  Předpokládejme, že existuje optimální tah minimální alokace $T$, kde alokujeme tým $z$, který odbavuje incident $i \in I$.
  Směnu naalokovanému týmu $d \in D$ přiřazujeme tak, aby směna $z$ plánu $T(p)$ byla co nejkratší a zároveň aby začínala co nejpozději.
  Taková směna je jenom jedna.

  Zároveň buď je optimálním tahem pouze tah minimální alokace týmu nebo pouze tah minimální alokace týmu spolu s vozidlem.

  Počet minimálních prodloužení směny je nanejvýš
  \begin{alignat*}{2}
    Z_2, \quad && \hspace{15pt} \text{počet naalokovaných vozidel.}
  \end{alignat*}
  Předpokládejme, že existuje optimální tah minimální prodloužení $T$, kde prodlužujeme tým $z$, který nově odbavuje incident $i \in I$.
  Směnu naalokovanému týmu $d \in D$ přiřazujeme tak, aby směna týmu $z$ plánu $T(p)$ byla co nejkratší.
  Taková směna je opět jenom jedna.

  Zároveň buď je optimálním tahem pouze tah minimální prodloužení směny týmu nebo pouze tah minimální prodloužení směny týmu spolu s alokací vozidla.

  Jelikož $Z_1 + Z_2 = Z_n$ a tah identita lze provést vždy a je jenom jeden, tak dohromady dostáváme:
  \begin{equation*}
    1 \leq |T| \leq Z_n + 1.
  \end{equation*}
\end{dukaz}

\begin{definice}[Strom optimálních tahů]
  Strom optimálních tahů rozumíme strom rekurze algoritmu prohledávání prostoru plánů optimálními tahy \ref{alg:rekProhPlanu}.
\end{definice}

\begin{veta}[Velikost stromu optimálních tahů]\label{veta:velikostStromuR}
Počet vrcholů stromu optimálních tahů je nanejvýš
  \begin{equation*}
    \frac{(Z_n + 1)^{|I| + 1}}{Z_n} \in \mathcal{O} \left (Z_n^{|I| + 1} \right ).
  \end{equation*}
\end{veta}
\begin{dukaz}
  Větvení stromu je dáno počtem optimálních tahů.
  Z věty \ref{veta:pocetOptTahu} jich je nanejvýš $Z_n + 1$.
  Hloubka stromu je $|I|$, proto
  počet vrcholů stromu činí nanejvýš
  \begin{equation*}
    \sum_{k=0}^{|I|} (Z_n + 1)^{k} = \frac{(Z_n + 1)^{|I| + 1}}{Z_n}.
  \end{equation*}
\end{dukaz}

\begin{veta}[Složitost alogirtmu rekurzivního prohledávání optimálních tahů \ref{alg:rekProhPlanu}]\label{veta:slozitostRek}
  Algoritmus rekurzivního prohledávání optimálních plánů \ref{alg:rekProhPlanu} běží v čase
  \begin{equation*}
    \mathcal{O}((Z_n + 1)^{|I| + 1}).
  \end{equation*}
\end{veta}
\begin{dukaz}
  Z věty \ref{veta:velikostStromuR} je počet vrcholů stromu optimálních tahů nanejvýš
  \begin{equation*}
    \frac{(Z_n + 1)^{|I| + 1}}{Z_n}.
  \end{equation*}
  V každém vrcholu procházíme všechny optimální tahy plánu, z věty \ref{veta:pocetOptTahu} jich je nanejvýš $Z_n + 1$.
\end{dukaz}

Nalezli jsme korektní algoritmus při účelové funkci $q^{\text{Lex}}$, který běží v exponenciálním čase podle počtu incidentů. 
To je stále dramatické zlepšení oproti naivnímu řešením \ref{df:naivniRes}, jehož složitost je rovna velikosti množiny plánů \ref{veta:velikostP}.

Každý vrchol stromu optimálních tahů $v$ v hloubce $h$ odpovídá nějakému plánu optimálnímu v ceně $p$ odbavující nanejvýš $h$ incidentů.
Cesta z kořene stromu, prázdného plánu $p_0$, do vrcholu $v$, odpovídá nějaké posloupností optimálních tahů délky $log_{(Z_n + 1)}(h)$:
\begin{equation*}
  A_1 \circ T^1_1 \circ \dots \circ T^1_k \circ A_2 \circ T^2_1 \circ \dots \circ T^2_l \circ A_3 \circ \dots \circ A_n,
\end{equation*}
kde $A_i$ značí tah minimální alokace týmu a tahy $T^i_j$ jsou tahy minimální prodloužení směny týmu naalokovaného $A^i$ nebo identita.

V jakém pořadí provedeme tahy alokace $A_1 \dots A_n$ nezáleží. Jestli první naalokujeme tým $z_1$ a pak tým $z_2$ nebo naopak, neovlivní výsledný získaný plán.
To stejné platí pro tahy $T^i_1 \dots T^i_j$ -- nezáleží, jestli je první prodloužena směna týmu $z$ o čas $d_s$ a pak o čas $d_l$, nebo naopak. Výsledná délka směny $z$ bude vždy rovna $d_s + d_l$.
Avšak nelze prodlužovat směnu týmu, který ještě není naalokován. Tahy prodloužení $T^i_1 \dots T^i_j$ se můžou provádět až po alokaci $A_i$.
Tahy identita jsou komutativní s jakýmkoliv jiným tahem.

Z toho plyne, že libovolnou permutací tahů $T^i_1 \dots T^i_j$ přes všechny alokace $A_1 \dots A_n$, kde tahy prodloužení směny $T^i_k \in T^i_1 \dots T^i_j$ následují po $A_i$
a tahy identita lze provést kdykoliv, získáme stejný plán.

Takových posloupností může být poměrně hodně, protože se jedná o nějaké permutace na $T^i_1 \dots T^i_j$ zkombinované s výběry $A_i$.
Z toho důvodu jsme v algoritmu $\ref{alg:rekProhPlanu}$ zavedli \textit{Cache}, abychom neprohledávali podstrom různých vrcholů stejného plánu několikrát.
Pamatování si mezivýsledků se v dynamickém programování obecně říká \textit{memoizace} a díky ní bude algoritmus znatelně rychlejší než horní odhad \ref{veta:slozitostRek}.

Jak moc rychlejší přímo spočítat nelze -- jaké posloupnosti optimálních tahů jsou prohledávány příliš záleží na výpočtu simulace. 

\section{Metaheuristické metody}\label{kap:heuristiky}

V kapitole \ref{kap:NP} jsme diskutovali, do jaké třídy složitosti patří optimalizační úloha nalezení optimálního pohotovostního plánu.
Konkrétně jsme si ve větě \ref{veta:simulaceJakoCernaSkrinka} ukázali, že pokud na účelovou funkci budeme nahlížet jako na černou skříňku,
tak je optimalizační úlohu NP-těžká. V minulé kapitole jsme nalezli rekurzivní vztah, který nám umožnil se na
účelovou funkci nedívat jako na černou skříňku a nalezli jsme dramaticky lepší algoritmus \ref{alg:rekProhPlanu}, než naivní řešení \ref{kap:naivniRes}.

V této kapitole jsou diskutovány metody, které na účelovou funkci pohlížejí jako na černou skřňku. 
Připouštíme tedy NP-těžkou složitost problému, ale ukáže se, že i tak budeme schopni docílit velmi kvalitních pohotovostních plánů.

\subsection{Popis}

\textit{Metaheuristické prohledávání prostoru konfigurací} patří mezi nejefektivnější způsoby řešení těžkých optimalizačních problémů,
jak diskrétních tak spojitých,
které nelze jednoduše vyřešit v polynomiálním čase.
Tyto metody prohledávání prostoru konfigurací koordinují interakce mezi lokálním a globálním optimalizováním,
aby byli schopny prohledávat lokálně optimální konfigurace, ale zároveň aby z nich mohli uniknout a prostor prohledávat robustně.
Často metaheuristiky při prohledávání využívají konceptu \textit{sousedství}.
Míra, do jaké jsou sousedství využívána, se liší podle konkrétního typu metody.
Některé metaheuristiky, jako například \textit{simulované žíhání} nebo \textit{tabu prohledávání}, využívají \textit{přípustné tahy},
pomocí kterých přecházejí z jednoho řešení na jiné v lokálním pohledu.
Zároveň dochází k výběru v lokálním pohledu horších konfigurací, aby se zajistila robustnost prohledávání
a metoda neuvázla pouze v lokálním optimu.
V případě metod, založených na \textit{populaci}, jako jsou například \textit{genetické algoritmy}, jsou sousedství implicitně definována
nahrazováním komponent jednoho řešení komponentami jiného řešení, různě zvolenými pravidly výměny.
Dalším příkladem populačních algoritmů je rodina \textit{ant colony optimization} metod,
kde jsou sousedství definována propojením cest a procházena pomocí simulování chodu populací mravenců po těchto cestičkách
s pravděpodobností, jenž je uřčena feromony.
Existuje spoustu dalších různých metod, jako v poslední době populární \textit{hybridní metody},
které propojují více metaheuristických metod dohromady, s myšlenkou použít každou metaheuristiku co nejvhodněji,
případně i měnit různé metaheuristiky za běhu (\citet{GlovKoch03}).

\subsection{Lokální prohledávání}

Asi nejjednodušší metoda na prohledávání prostoru konfigurací je \textit{lokální prohledávání}.
Lokální prohledávání pouze lokálně prohledává prostor konfigurací od nějaké startovní konfigurace $x \in \mathcal{X}$. 
Prostor porhledává prostřednictvním sousedů, kde vždy vybere souseda s nejlepší hodnotou účelové funkce.
Náhodná konfigurace i sousedi musí splňovat omezení, pokud nějaká jsou.
Aby metoda lokálního prohledávání pomocí sousedů správně fungovala, musí sousedi konfigurace $x$ být v nějakém smyslu $x$ podobné (\citet{HybridMeta}, str. 3).

\begin{algorithm}[H]
  \begin{algorithmic}[1]
    \Function{LocalSearch}{$p_{start}$, $I$}
    \State $p_{current}$ \gets $p_{start}$
    \While {true}
      \State $p^*$ \gets $p_{\emptyset}$ 
      \For {$p \in \text{neighbours($p_{current}$)}$}
        \If {$q(p, I) > q(p^*, I)$}
          \State $p^*$ \gets $p$
        \EndIf
      \EndFor
      \If {$p^* = p_{\emptyset}$}
        \State \Return $p_{current}$
      \EndIf
      \State $p_{current}$ \gets $p^*$
    \EndWhile
  \EndFunction
  \end{algorithmic}
  \caption{Lokální prohledávání plánů pohotovostních služeb}
  \label{alg:hillclimb}
\end{algorithm}

Algoritmus \ref{alg:hillclimb} v krocích 3 až 14 prohledává sousedy dokud není splněna podmínka v kroku 10.
Algoritmus v kroku 5 prohledává sousední plány splňující omezující podmínky $C$, aktuálně prohledávaného plánu $p_{current}$, který je na začátku algoritmu v kroku 2 nastaven na $p_{start} \in P_C$.
V krocích 6 a 7, pokud má soused lepší hodnocení pří účelové funkci $q \in Q_I$, tak je aktuálně nejlepší soused $p^*$ změněn na souseda $p$.
Podmínka v kroku 10 kontroluje, zda existuje nějaký soused $p_{current}$, který má lepší hodnocení při $q$.
Pokud ne, algoritmus našel lokální maximum, tím je $p_{current}$, proto je vrácen v kroku 11.
V kroku 13 je $p_{current}$ nastaveno na nejlepší sousední plán.
Zřejmě lokální prohledávání nalezne nějaké lokální maximum, jaké konkrétně, závisí pouze na startovním plánu $p_{start}$.

Sousedy plánu $p \in P_C$ lze získat různými způsoby, je však důležité, aby byli $p$ v nějakém smyslu podobní.
Jako podobné plány plánu $p$ můžeme chápat plány, které se od $p$ liší co nejméně, například pouze jednou alokací týmu nebo vozidla,
nebo v jedné směně nějakého týmu, atd.\

\textit{Sousedy} $p$ tak nadefinujeme jako plány $N_p \subseteq P_C$, které vzniknou aplikováním tahu $T$,
\begin{align*}
  T(p) \in P_C,
\end{align*}
kde $T$ může být jeden z následujících \textit{sousedních tahů}:
\begin{enumerate}
  \item alokování záchranného týmu,
  \item dealokování záchranného týmu,
  \item alokování záchranného vozidla,
  \item dealokování záchranného vozidla,
  \item nejkratší prodloužení směny záchranného týmu,
  \item nejkratší zkrácení směny záchranného týmu,
  \item posun začátku směny záchranného týmu o nejkratší možnou dobu.
\end{enumerate}
Sousedy $N_p$ jsme tak zkonstruovali implicitně pomocí tahů, což je standardní způsob konstrukce sousedů nějaké konfigurace (\cite{HybridMeta}, str. 3).

Všechny prohledané plány nebudou navzájem různé,
například první dealokace vozidla a pak prodloužení směny nějakému týmu nebo obráceně vyústí ve stejné plány.
Při implementaci tak dává smysl použít \textit{cache},
abychom se vyhnuli opakovanému výpočetně náročnému spouštění simulace pro stejné plány, pouze získané jinou posloupností tahů, podobně jako v algoritmu \ref{alg:rekProhPlanu}.

Mohlo by nás zajímat, až kolik sousedů $N_p$ nějaký plán $p$ může mít.
Velikost množiny $N_p$ se bude rovnat počtu různých sousedních tahů, 
protože každým takovým tahem získáme unikátní plán. 

\begin{veta}[Počet sousedů]
  Nechť libovolný plán $p \in P_C$, pak
  \begin{align*}
  |N_p| \in \mathcal{O}(Z_n + A_n),
  \end{align*}
  kde $N_p$ jsou sousedi plánu $p$.
\end{veta}
\begin{dukaz}
  Nechť $Z_1$ počet naalokovaných týmu a $Z_2$ počet nenaalokovaných týmů, zřejmě
  \begin{align*}
    Z_1 + Z_2 = Z_n.
  \end{align*}
  Definujme stejně $A_1$ a $A_2$ jako počty naalokovaných a nenaalokovaných vozidel.
  Tahy počítejme postupně.
  Počet tahů alokování záchranného týmu je počet nenaalokovaných záchranných týmů, $Z_2$.
  Tahů dealokování týmu samozřejmě $Z_1$.
  Stejně tak pro alokace a dealokace záchranných vozidel, čili $A_2$ a $A_1$ tahů.
  Nejkratší prodloužení a zkrácení směny týmu je nanejvýš jedna pro každý naalokovaný tým.
  Stejně tak pro posun začátku směny o nejkratší možnou dobu.
  Dohromady dostáváme
  \begin{align*}
    (Z_1 + Z_2) + (A_1 + A_2) + 4 * Z_1 = Z_n + A_n + 4 * Z_1 \in \mathcal{O}(Z_n + A_n).
  \end{align*}
\end{dukaz}

Pokud lokální prohledávání skončí v $k$ krocích, tak algoritmus prohledá $\mathcal{O}(k \cdot (Z_n + A_n))$ plánů.
Jak uvidíme v kapitole (ref TODO), počet kroků $k$ k docílení lokálního optima z nějakého startovního plánu se pohybuje v desítkách,
takže $k$ můžeme uvažovat jako konstantu.

Získáváme tak velmi rychlý způsob, jak upravit libovolný plán, abychom dostali jeho \uv{nejlepší verzi}. 
Startovní plán definuje nějaký základ, který je následně doplňován nebo redukován o záchranné týmy nebo vozidla,
nebo jsou týmům postupně prodlužovány či zkracovány směny,
dokud jakákoliv změna už pouze nezhorší výslednou kvalitu. 

Velkou nevýhodou lokálního prohledávání je neschopnost umět nalézt kompromis mezi lokálním optimem a globálním optimem,
přičemž nalezené lokální optimum je v drtivé většině suboptimální (\cite{GlovKoch03} str. 43).

\subsection{Tabu prohledávání}

Tabu prohledávání stejně jako lokální prohledávání prohledává plány lokálně pomocí sousedů.
Tabu prohledávání však narozdíl od lokálního prohledávání po nalezení lokálního optima v něm nezůstane,
ale umožní i navštívit souseda s horším hodnocením.

Aby se následně prohledávání nevrátilo zpět do stejného optima,
drží si seznam inverzních tahů posledních provedených tahů. Tomuto seznamu se říká \textit{tabu} a jedná se o tahy, které 
jsou při prohledávání zakázany.
Velikost seznamu tabu je takzvaná \textit{tabu tenura}, a jelikož se vždy ze seznamu odstraní nejposledněji provedený tah,
tak tabu tenura určuje po jaký počet kroků tabu prohledávání se tah uvažuje, že je zakázan. 

Ovšem vždy zakázat tahy z tabu může být příliš omezující, a výsledná nalezená řešení by mohla být suboptimální.
Z toho důvodu ještě tabu metoda využívá konceptu \textit{aspiračního kritéria}, které pokud je pro nějaký tah splěno,
tak je soused po provedení tohoto tahu uvažován i pokud je tah zakázan, čili i když se tah nachází v tabu.

Tabu prohledávání lze ukončit několika způsoby. Nejčastěji se prohledávání ukončuje, jakmile v iteraci už neexistují žádní zlepšující sousedé,
které získáme tahem, jenž není v tabu.~(\cite{GlovKoch03} str. 41 -- 49). 

\begin{algorithm}[H]
  \begin{algorithmic}[1]
    \Function{TabuSearch}{$p_{start}$, $I$, $t$}
    \State $p_{current}$ \gets $p_{start}$
    \State $p_{best}$ \gets $p_{start}$
    \State $tabu\_list$ \gets \{\}
    \While {true}
      \State $p^*$ \gets $p_{\emptyset}$ 
      \For {$T \in \text{neighbours\_moves($p_{current}$)}$}
        \State $p$ \gets T($p_{current}$)
        \If {$q(p, I) > q(p^*, I)$} \textbf{and} ($p \notin tabu\_list$ \textbf{or} $q(p, I) > q(p_{best}, I)$)
          \State $p^*$ \gets $p$
        \EndIf
      \EndFor
      \If {$p^* = p_{\emptyset}$}
        \State \Return $p_{best}$
      \EndIf
      \State $p_{current}$ \gets $p^*$
      \If {$q(p_{current}, I) > q(p_{best}, I)$}
        \State $p_{best}$ \gets $p_{current}$
      \EndIf
      \State \text{AddFirst(tabu\_list, $T^{-1}$)}
      \If {$|\text{tabu\_list}| > t$}
        \State \text{RemoveLast($tabu\_list$)} 
      \EndIf
    \EndWhile
    \State \Return $p_{best}$
  \EndFunction
  \end{algorithmic}
  \caption{Tabu prohledávání plánů pohotovostních služeb}
  \label{alg:tabusearch}
\end{algorithm}

V krocích 1--5 se inicializuje stav algoritmu. Tabu je ze začátku prázdné.
Podobně jako v lokálním prohledávání se prohledává prostor v krocích 5 až 24, dokud není splněna podmínka na řádku 13.
V krocích 7--12 se prohledávájí pomocí sousedních tahů sousedé aktuálně prohledávaného plánu $p_{current}$. 

Nejzajímavější je krok 9. Zde se prvně kontroluje stejně jako v lokálním prohledávání, zda je splěna nutná podmínka, jestli je vůbec třeba souseda $p$ uvažovat.
Druhá podmínka kontroluje, zda $p$ buď není v tabu, nebo je splněné aspirační kritérium.
Tah $T$, který je v tabu uvažujeme pouze pokud soused $T(p_{current})$ je doposavad nejoptimálnějším nalezeným plánem.
Takové aspirační kritérium je nejčastěji používané a obecně nejefektivnšjí aspirační kritérium~(\cite{GlovKoch03} str. 47).

Podmínka v kroku 13 je totožná s podmínkou u lokálního prohledávání.
Pokud již neexistuje žádný zlepšující soused, který není v tabu nebo nesplňuje aspirační kritérium, tak vrátíme nejlepší nalezený plán $p_{best}$.
V kroku 17 aktualizujeme $p_{best}$, pokud jsme v aktuální iteraci nalezli kvalitnější plán.

V poslední řadě, v krocích 20--23 aktualizujeme tabu.
Do taba přidáváme inverzní tah, protože se ze souseda nechceme vrátit do původního plánu.
Pokud je tabu větší než dovoluje hyperparametr tabu tenura $t$, odebereme nejdříve přidaný tah.

Tabu prohledávání již narozdíl od lokálního prohledávání nezůstane uvězněné v lokálním optimu a díky tabu se do něj nevrátí a nezacyklí se.
Prohledá tak více plánů a bude vracet lepší řešení, než lokální prohledávání.
Na druhou stranu, nalezená řešení budou stále poměrně dost závislá na $p_{start}$, protože algoritmus uvažuje jenom sousední plány.
Tento problém řeší následující algoritmus.

\subsection{Simulované žíhání}



