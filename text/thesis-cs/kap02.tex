\chapter{Řešení optimalizační úlohy}\label{chap:reseniOptUloh}

V této kapitole vyzkoušíme různé metody, které můžeme pro nalezení optimálního plánu pohotovostní služby použít.

\section{Dynamické programování}\label{kap:dynamicProgram}

\subsection{Popis}

\textit{Dynamické programování} je technika řešení problému, která si průběžně ukládá řešení menších podúloh a pomocí rekurzivního vztahu menší podúlohy s větší,
definovaného \textit{rekurzivním vztahem}, řeší větší podúlohy efektivněji, až po vyřešení původní úlohy. 
Průběžnému ukládání výsledků podúloh se říká \textit{memoizace}.
Díky této memoizaci dynamické programování neprohledává prostor řešení duplicitně, a tak je často velmi efektivní metodou pro řešení optimalizačních úloh \cite{dynamic}.

Triviálním příkladem využití dynamického programování je výpočet $n$-tého \textit{Fibbonaciho čísla} \cite{mares}.
Pro nás zajímavějším příkladem využití dynamického programování je řešení úlohy kombinatorické optimalizace \textit{Problému batohu}.

\begin{definice}[Problém batohu]
  Nechť $n$ počet předmětů, které chceme vložit do batohu s kapacitou $c$.
  Každý předmět $i$ má výdělek $p_i$ a váhu $w_i$. Problém batohu pak je,

  \begin{alignat*}{2}
    &\normalfont \text{maximalizování} \hspace{30pt} &z = \sum_{i=1}^n p_i x_i, \\
    &\normalfont \text{splňující}   \hspace{30pt} &\sum_{i = 1}^{n} w_i x_i \leq c,
  \end{alignat*}
  \\
  kde $x_i = 1$, pokud předmět $i$ je v batohu, jinak $0$.
  \\
\end{definice}

Existuje $2^n$ možností, které předměty vložíme do batohu. Naivní řešení prohledání všech možností tak běží v čase $\mathcal{O} (2^n)$.
Avšak pomocí dynamického programování lze vyřešit problém batohu v \textit{pseudopolynomiálním} čase $\mathcal{O}(nc)$,
což pro velká $n$ a konstatní $c$ je až exponenciálním zlepšením.

Rekurzivní vztahy vypadají následovně,

\begin{definice}[Rekurzivní vztah pro problém batohu]\label{rov:KPrekurz}
  \begin{align}
    m_{i, c'} &= m_{i - 1, c'} \text{ pokud } w_i > c', \\
    m_{i, c'} &= \max (m_{i - 1, c'}, m_{i - 1, c' - w_i} + p_i) \text{ pokud } w_i \leq c',
  \end{align}
  \\
  pro $0 \leq c' \leq c$ aktuální uvažovaná kapacita batohu.
\end{definice}

Rekurzivní vztah (viz rovnice \ref{rov:KPrekurz}) nám pouze říká, že ze znalostí optimálního výběru předmětů podpbroblému $m_{i-1, c' - w_i}$ a podproblému $m_{i - 1, c'}$,
umíme v konstantím čase zjistit optimální výběr předmětů pro aktuální problém $c'$, tedy $m_{i, c'}$.
Buď předmět $i$ použijeme při výběru, a tak aktuální optimální výběr je roven $m_{i - 1, c' - w_i} + p_i$,
nebo předmět při výběru nepoužijeme, takže aktuální optimální výběr je optimální výběr podproblému, $m_{i - 1, c'}$. 

\begin{algorithm}[h]
  \begin{algorithmic}[1]
  \Function{KnapsackProblem}{$n$, $c$, $p_i$, $w_i$, $1 \leq i \leq n$}
    \State $m_{i, j}$ \gets 0, $0 \leq i \leq n$, $0 \leq j \leq c$
    \For{$1 \leq i \leq n$}
      \For{$1 \leq j \leq c$}
        \If{$w_i > j$}
          \State $m_{i, j}$ \gets $m_{i - 1, j}$
        \Else
          \State $m_{i, j}$ \gets $\max$ ($m_{i - 1, j}$, $m_{i - 1, j - w_i} + p_i$)
        \EndIf
      \EndFor
    \EndFor
    \State \Return $m_{n,c}$
  \EndFunction
  \end{algorithmic}
  \caption{Problém batohu}
  \label{KP}
\end{algorithm}

Algoritmus \ref{KP} vrací sumu hodnot optimálních předmětů přidaných do batohu.
Jaké konkrétní předměty přispěly do sumy lze snado zjistit zpětným následováním rekurzivního vztahu.

Rádi bychom našli nějaký podobný rekurzivní vztah v problému hledání optimálního plánu.
Nalezením rekurzivních vztahů by pak simulace $s$ nebyla černou skříňkou a byla by splněna nutná podmínka (viz věta \ref{veta:simulaceJakoCernaSkrinka}) pro šanci na polynomiální řešení.

\subsection{Prohledávání prostoru plánů tahy}

V předchozí kapitole jsme si ukázali, jak se obecně dynamickým programováním dá 
vyřešit náročná kombinatorická úloha.

V této kapitole budeme zkoumat, jestli existují nějaké rekurzivní vztahy 
\uv{optimálních plánu} na méně incidentech s \uv{optimálními plány} na více incidentech, abychom efektivně vyřešili optimalizační problém nalezení optimálního plánu pohotovostní služby. 

Nalezneme takový rekurzivní vztah (viz věta \ref{veta:optimalniTahy}) a to pomocí prohledávání plánů pomocí \textit{tahů} (viz definice \ref{df:tah}),
konkrétně \textit{optimálních tahů} (viz definice \ref{df:optimalniTahy}).
Optimálními tahy budeme postupně budovat \textit{plány optimální v ceně} (viz definice \ref{df:planOptVCene}),
podle vhodně zvolených podmnožin množiny incidentů $I$, \textit{seřazených incidentů} (viz definice \ref{df:INC}).
Věta o dosažitelnosti optimálními tahy \ref{veta:dosazitelnostOptimalnimiTahy} dokáže, že takový postup skutečně musí nalézt všechny optimální plány, ale pouze při účelové funkci $q^{\text{Lex}}$.
Také navrhneme algoritmus (viz algoritmus \ref{alg:rekProhPlanu}),
který korektně nalezne všechny takové optimální plány pro množinu $I$, a bude fungovat rychleji než naivní řešení.
Detailní rozebrání složitosti algoritmu popisuje věta o složitosti algoritmu \ref{veta:slozitostRek}.

\begin{definice}[Seřazené incidenty]\label{df:INC}
  Nechť množina incidentů 
  \begin{equation*}
    I = \{ i_1, \dots , i_n \} \text{, kde } \forall_{j \not = k} j, k \in \{ 1, \dots n\} \colon T_I(i_j) < T_I(i_k),
  \end{equation*}
  čili incidenty jsou seřazené podle času nastání.
  Definujme množiny incidentů
  \begin{equation*}
    \emptyset = I_0, I_1, \dots, I_n \text{, kde } \forall k \in \{ 1, \dots, n \} \colon I_k = \{ i_1, \dots, i_k \}.
  \end{equation*}

  Incidenty $I_k$ jsou tak incidenty $I_{k-1}$ po odebrání incidentu $i_k$, který se odehrál jako poslední.
\end{definice}

Pomocí seřazených incidentů budeme postupně konstruovat plány optimální v ceně.
Z plánu optimálního v ceně pro $I_{k-1}$ získáme plány optimální v ceně pro $I_k$ pomocí \textit{tahů}, konkrétně nějakých \textit{optimálních tahů}.
\begin{definice}[Tah]\label{df:tah}
  Nadefinujme tah jako funkci $T \colon P_C \rightarrow P_C$.
  Pokud $p' = T(p)$, řekneme, že jsme plán $p'$ získali z $p$ tahem $T$.
\end{definice}

\begin{definice}[Inverzní tah]\label{df:tah}
  Nechť tah $T$. Inverzní tah $T^{-1}$ k tahu $T$ je tah, pro který platí
  \begin{align*}
    T(p) = p' \Leftrightarrow T^{-1}(p') = p.
  \end{align*}
\end{definice}

Můžeme pak nějakou posloupností tahů převést jeden plán na druhý.
\begin{definice}[Posloupnost tahů]
  Posloupností tahů velikosti $n$ rozumíme posloupnost tahů $T_1, T_2, \dots, T_n$.
  Řekneme, že z plánu $p$ získáme plán $p'$ posloupností tahů $T_1, T_2, \dots, T_n$,
  pokud $(T_1 \circ T_2 \circ \dots \circ T_n)(p) = p'$, kde symbol $\circ$ značí binární operaci skládání funkcí,
  kde se první vyhodnotí levá funkce a pak pravá.
\end{definice}

Následující \textit{kanonické tahy} jsou zajímavé z toho důvodu, že vhodnými posloupnostmi vhodných kanonických tahů získáme \textit{optimální tahy},
právě kterými budeme postupně budovat pro množiny incidentů $I_{k-1}$ až $I_k$ plány optimální v ceně. 

\begin{definice}[Kanonické tahy]
  Kanonickými tahy rozumíme tahy
  \begin{enumerate}
    \item
      Alokace záchranného týmu na výjezdovou stanici.

    \item
      Alokace záchranného vozidla na výjezdovou stanici.

    \item
      Prodloužení doby trvání směny již naalokovaného záchranného týmu. 

    \item
      Identita.
  \end{enumerate}

  Formálně,
  \begin{enumerate}
    \item
      kanonický tah alokace týmu $z'$ na výjezdovou stanici je tah $T$, kde
      \begin{align*}
        p_Z'(z) &=
          \begin{cases}
            v \neq v_{\emptyset} & \text{pro tým $z' \in Z \colon p_Z(z') = v_{\emptyset}, v \in V$}, \\
            p_Z(z) & \text{pro $\forall z \in Z \setminus \{ z' \}$},
          \end{cases}
          \\
        p_D'(z) &=
          \begin{cases}
            (d_s, d_l) \in D \colon d_l - d_s > 0 & \text{pro $z'$}, \\
            p_D(z) & \text{pro $\forall z \in Z \setminus \{ z' \}$},
          \end{cases}
          \\
        p_A'(a) &= p_A(a), \forall a \in A,
      \end{align*}

      pro $p_Z, p_D, p_A \in p$ a $p_Z', p_D', p_A' \in p'$, kde $p, p' \in P_C$ a $T(p) = p'$.

    \item
      Kanonický tah alokace záchranného vozidla $a'$ na výjezdovou stanici je tah $T$, kde
      \begin{align*}
        p_Z'(z) &= p_Z(z), \forall z \in Z,
        \\
        p_D'(z) &= p_D(z), \forall z \in Z,
        \\
        p_A'(a) &=
        \begin{cases}
          v \neq v_{\emptyset} & \text{pro záchranné vozidlo $a' \in A \colon p_A(a') = v_{\emptyset}, v \in V$}, \\
          p_A(a) & \text{pro $\forall a \in A \setminus \{ a' \}$},
        \end{cases}
      \end{align*}

      pro $p_Z, p_D, p_A \in p$ a $p_Z', p_D', p_A' \in p'$, kde $p, p' \in P_C$ a $T(p) = p'$.

    \item
      Kanonický tah prodloužení směny týmu $z'$ je tah $T$, kde
      \begin{align*}
        p_Z'(z) &= p_Z(z), \forall z \in Z \\
        p_D'(z) &=
          \begin{cases}
            (d'_s, d'_l) \in D \colon d'_l > d_l \land d'_s = d_s  & \text{pro $z'$} \\
            p_D(z) & \text{pro $\forall z \in Z \setminus \{ z' \}$},
          \end{cases}
          \\
        p_A'(a) &= p_A(a), \forall a \in A,
      \end{align*}

      pro $p_Z, p_D, p_A \in p$ a $p_Z', p_D', p_A' \in p'$, kde $p, p' \in P_C$ a $T(p) = p'$.

    \item
      Kanonický tah posun začátku směny týmu $z'$ je tah $T$, kde
      \begin{align*}
        p_Z'(z) &= p_Z(z), \forall z \in Z \\
        p_D'(z) &=
          \begin{cases}
            (d'_s, d'_l) \in D   & \text{pro $z'$} \\
            p_D(z) & \text{pro $\forall z \in Z \setminus \{ z' \}$},
          \end{cases}
          \\
        p_A'(a) &= p_A(a), \forall a \in A,
      \end{align*}
      pro
      \begin{equation*}
        (d'_s, d'_l) \colon d'_s \in D_S \land d'_l = p_{D_L}(z') \land d'_s < d'_l
      \end{equation*}
      a $p_Z, p_D, p_A \in p$ a $p_Z', p_D', p_A' \in p'$, kde $p, p' \in P_C$ a $T(p) = p'$.

    \item
      Kanonický tah identita je tah $T: p \rightarrow p$.
  \end{enumerate}

\end{definice}

Dále budeme tahy definovat pouze slovně, protože se bude vždy jednat o nějaké posloupnosti kanonických tahů nebo o jejich inverze.

Můžou existovat plány $p \in P_C$, na kterých nějaký tah nelze provést, čili $T(p)$ je nedefinované.
Například, pokud bychom plánu chtěli alokovat tým, ale už nejsou žádné k dispozici, nebo už není volná žádná výjezdová stanice podle omezení $C$.
Řekněme, že tah $T$ \textit{lze provést na plánu $p \in P_C$} právě tehdy, když $T(p)$ je definováno.

Pomocí tahů můžeme $P_C$ \textit{prohledávat}.
Plán $p_2$ \textit{je dosažitelný tahy $T$ z plánu $p_1$}, pokud existuje posloupnost tahů $T_1, \dots, T_n$ taková, že $(T_1 \circ \dots \circ T_n)(p_1) = p_2$.
Pokud optimální plán $p^* \in P_C$ je nějakými tahy $T_i$ dosažitelný z $p \in P_C$, pak ho můžeme prohledáváním, které začíná v $p$ nalézt.
Pomocí tahů můžeme $P_C$ prohledávat sofistikovaněji, než je jenom všechny procházet, jak jsme dělali v naivním řešení \ref{df:naivniRes}.

Některé plány totiž ani nemá smysl prohledávat, jako například plány, které naalokují záchranáře tak nešikovně, že neodbavují úspěšně žádný incident.
Taková naalokování jenom přispívají do ceny plánu, ale nijak do počtu úspěšně odbavených incidentů.

Dále budeme zkoumat, jaké plány má smysl prohledávat a jakými tahy jsme takové plány schopni nalézt.
\begin{definice}[Tahy snižující cenu]\label{df:invKanTahy}
  Za tahy snižující cenu rozumíme tahy:
  \begin{enumerate}
    \item
      dealokování týmu,

    \item
      dealokování vozidla,

    \item
      zkrácení doby trvání směny,

    \item
      posun začátku směny na později a zkrácení doby trvání směny.

  \end{enumerate}
\end{definice}

Tahy 1--3 jsou inverzní kanonické tahy alokování týmu, alokování vozidla a prodloužení směny.
Tah 4 lze chápat jako zkrácení směny \uv{zleva}.

\begin{definice}[Plán optimální v ceně]\label{df:planOptVCene}
  Nechť množina incidentů $I$ a plán $p \in P_C \colon s(p, I) = r$.
  Řekneme, že $p$ je optimální v ceně právě tehdy, když
  pro plán $p'$ vzniklý z plánu $p$ provedením libovolného tahu snižujícího cenu platí: 
  \begin{equation*}
    s(p', I) < r.
  \end{equation*}
\end{definice}

Plán optimální v ceně je takový plán, že jakýkoliv pokus o snížení ceny nějakým tahem snižující cenu způsobí, že výsledný plán bude odbavovat méně incidentů.
Následující věta objasní, k čemu jsou plány optimální v ceně užitečné.
\begin{veta}[Optimální plán při účelové funkci $q^{\text{Lex}}$ je optimální v ceně]\label{veta:lexJeOptVCene}
  Optimální plán $p^*$ při účelové funkci $q^{\text{Lex}}$ na množině incidentů $I$ je optimální v ceně.
\end{veta}
\begin{dukaz}
  Pro spor předpokládejme, že $p^*$ není optimální v ceně.
  Pak existuje tah snižující cenu $T$ takový, že
  \begin{equation*}
    s(T(p^*), I) = s(p^*, I) \land u(T(p^*)) < u(p^*).
  \end{equation*}
  Plán $T(p^*)$ odbavuje stejně incidentů a zároveň je levnější.
  To je spor s optimalitou $p^*$ pří účelové funkci $q^{\text{Lex}}$.
\end{dukaz}

Z věty \ref{veta:lexJeOptVCene} plyne, že pokud bychom nalezli způsob, kterým budeme schopni prohledávat pouze plány optimální v ceně v množině $P_C$, tak nutně
nalezneme i všechny optimální plány při účelové funkci $q^{\text{Lex}}$.
Následujícím tahům budeme říkat \textit{optimální tahy}, a těmito tahy budeme schopni z prázdného plánu budovat pouze plány optimální v ceně.
Následuje definování jednotlivých optimálních tahů.

\begin{definice}[Tah minimální prodloužení směny týmu]
  Tahem \textit{minimální prodloužení směny týmu} na plánu $p \in P_C$ pro množinu incidentů $I_{k-1}$, rozumíme tah $T$, prodloužení směny týmu a případně alokace vozidla tak, že
  \begin{enumerate}
    \item
      $s(T(p), I_{k}) = s(p, I_{k-1}) + 1$,
    \item
      $T(p)$ je optimální v ceně.
    % \item
      % tým $z$ odbavuje $i \in I$ takový, že $p$ incident $i$ neodbavoval.
  \end{enumerate}
\end{definice}

\begin{definice}[Tah minimální alokace týmu]
  Tahem \textit{minimální alokace týmu} na $p \in P_C$ pro množinu incidentů $I_{k-1}$, rozumíme tah $T$, alokace týmu a případně alokace vozidla tak, že
  \begin{enumerate}
    \item
      $s(T(p), I_k) = s(p, I_{k-1}) + 1$,

    \item
      $T(p)$ je optimální v ceně,

    % \item
      % tým $z$ odbavuje $i \in I$ takový, že $p$ incident $i$ neodbavoval,

    \item
      $T$ alokuje směnu s nejpozdějším možným začátkem směny.
  \end{enumerate}
\end{definice}

\begin{definice}[Optimální tahy]\label{df:optimalniTahy}
  Optimálními tahy $T^*$ plánu $p \in P_C$ pro množinu incidentů $I$ rozumíme množinu tahů:
  \begin{enumerate}
  \item
    tah minimální prodloužení směny týmu,
  \item
    tah minimální alokace týmu,
  \item
    tah identita,
  \end{enumerate}
  které lze na plánu $p$ pro množinu $I$ provést.
\end{definice}

Následující věta vše spojí dohromady a poskytne základ pro postup, jak šikovně prohledávat plány pomocí optimálních tahů.
\begin{veta}[O optimálních tazích]\label{veta:optimalniTahy}
  Nechť množiny incidentů $I_0, \dots, I_n$ podle definice \ref{df:INC}.
  Nechť plán optimální v ceně $p_k \in P_C \colon s(p_k, I_k) = r$.
  Pak existuje plán optimální v ceně
  \begin{equation*}
    p_{k-1} \in P_C \colon s(p_{k-1}, I_{k-1}) = r \lor s(p_{k-1}, I_{k-1}) = r - 1
  \end{equation*}
  a optimální tah $T$ takový, že
  \begin{equation*}
    T(p_{k-1}) = p_k,
  \end{equation*}
  pro všechna $k \in \{ 1, \dots, n\}$.
\end{veta}
\begin{dukaz}
  Nechť $\forall k \in \{ 1, \dots, n\}$, $i_1, \dots, i_k$ incidenty $I_k$ a $i'_1, \dots, i'_r$ incidenty, které odbaví $p_k$.
  Rozlišme dvě situace, které mohou nastat:
  \begin{enumerate}
    \item
      $i'_r \neq i_k$,
      čili poslední odbavený incident $i'_r$ není poslední incident, který v $I_k$ nastal,

    \item
      $i'_r = i_k$, čili poslední odbavený incident $i'_r$ je poslední incident, který v $I_k$ nastal.
  \end{enumerate}
  V prvním případě je hledaný $p_{k-1}$ právě $p_k$ a tah $T$ identita.
  Platí $s(p_k, I_{k-1}) = r$, protože $p_k$ neodbaví poslední incident $i_k \not \in I_{k-1}$ a simulace incidenty prochází postupně (viz algoritmus simulace \ref{simulaceAlgo}),
  takže výpočet simulace na plánu $p_{k}$ a na množinách $I_k$ i $I_{k-1}$ je do $i_{k-1}$ incidentu totožný.
  Zároveň $p_k$ je optimální v ceně na $I_k$ a jelikož $p_k$ odbavuje stejné incidenty na $I_{k-1}$, tak je optimální v ceně i na $I_{k-1}$.

  V druhém případě, je poslední incident $i_k = i'_r$ plánem $p_k$ odbaven.
  Z toho důvodu $p_k$ na množině inidentů $I_{k-1}$ odbavuje incidenty $i'_1, \dots, i'_{r-1}$, o jeden méně -- opět, simulace incidenty prochází postupně.
  Platí tak,
  \begin{align*}
    s(p_k, I_{k-1}) = r - 1.
  \end{align*}
  Plán $p_k$ však nemusí být optimální v ceně, takže $T$ nemusí být tah identita jak pro případ $i'_k = i'_r$. 

  Nyní rozborem případů ukážeme, že v každé situaci, která může nastat, existuje optimální tah $T$ splňující znění věty.

  Uvažme tým záchranářů $z$, který odbavoval incident $i_k$.
  Pro tým $z$ pak pro spuštění simulace na plánu $p_k$ na množině incidentů $I_{k-1}$ platí:
  \begin{enumerate}
    \item
      Tým $z$ odbavuje jenom $i_k$, pak je v plánu $p_k$ naalokován zbytečně. O odbavení všech ostatních $r-1$ incidentů se postarájí ostatní týmy.

    \item
      Tým $z$ odbavuje i jiné incidenty $I_z$, ale jelikož každý $z_i \in I_z$ nastal dříve,
      tak $z$ odbavuje $i_k$ až po odbavení všech incidentů $I_z$.
      Zde využíváme předpokladu, že incidenty se odehrávájí v různých časech (viz definice $I$ v kapitole \ref{kap:formalizaceProblemu}).
      Aby $z$ úspěšně odbavil $i_k$ , může mít delší směnu, než by potřeboval pro odbavení všech incidentů $I_z$.
  \end{enumerate}
  V obou případech ještě může být zbytečně naalokováno vozidlo, které $z$ používal pro odbavení $i_k$.
  Žádná jiná možnost nemůže nastat.

  Z pozorování plyne, že vždy existuje dvojice tahů $T_1^{-1}$ a $T_2^{-1}$, kde pro jejich složení $T^{-1} = T_1^{-1} \circ T_2^{-1}$,
  platí, že $T^{-1}(p_k)$ je optimální v ceně a $s(T^{-1}(p_k), I_{k-1}) = r - 1$.
  Těmito tahy jsou:
  \begin{enumerate}
  \item
    dealokace týmu a dealokace vozidla, \label{en:_1}
  \item
    dealokace týmu a identita, \label{en:_2}
  \item
    maximální zkrácení směny týmu a dealokace vozidla, \label{en:_3}
  \item
    maximální zkrácení směny týmu a identita, \label{en:_4}
  \item
    identita a identita. \label{en:_5}
  \end{enumerate}
  Maximálním zkrácením směny týmu $z$ myslíme tah zkrácení směny $T'$, že
  \begin{equation}\label{eq:rrr}
    s(T'(p_k), I_{k-1}) = r - 1
  \end{equation}
  a směna už týmu $z$ nelze zkrátit více, aby platila rovnost \ref{eq:rrr}.

  Případ \ref{en:_1} a případ \ref{en:_2} pokrývají situaci, kdy $z$ odbavuje pouze $i_k$.
  Případ \ref{en:_3} a případ \ref{en:_4} pokrývají situaci, kdy $z$ odbavuje i nějaké jiné incidenty a $z$ jde zkrátit směnu, aby stále odbavoval všechny incidenty $I_z$.
  Poslední případ \ref{en:_4} pokrývá situaci, kdy $z$ odbavuje i jiné incidenty, ale směnu mu nelze nijak zkrátit.

  Ukázali jsme tak existenci $T^{-1}$ pro všechny situace. Nechť
  \begin{equation*}
    T = T_1 \circ T_2,
  \end{equation*}
  kde $T_1$ a $T_2$ jsou inverzními tahy k $T_1^{-1}$ a $T_2^{-1}$.
  Alokace týmu jsou minimální, protože $p_k$ byl plán optimální v ceně.
  Dohromady dostáváme, že tah $T$ je optimální tah, a to v každém případě.
\end{dukaz}

Předchozí věta je velmi důležitá pro navrhnutí sofistikovanějšího algoritmu prohledávání plánů.
V následující větě je její tvrzení využito pro dokázání dosažitelnosti libovolného optimálního plánu, ale pouze při účelové funkci $q^{\text{Lex}}$.

\begin{veta}[O dosažitelnosti optimálního plánu optimálními tahy]\label{veta:dosazitelnostOptimalnimiTahy}
  Optimální plán $p^* \in P_C$ na množině incidentů $I$ při účelové funkci $q^{\text{Lex}}$ je z $p_0 = p_{\emptyset}$
  dosažitelný nějakou posloupností optimálních tahů $T_0 \circ \dots T_{|I|-1}$.
\end{veta}
\begin{dukaz}
  Nechť $n = |I|$ a
  nechť plán $p^*$ odbavuje $r = s(p^*, I)$ incidentů.
  Z věty \ref{veta:lexJeOptVCene} je $p^*$ optimální v ceně.
  Existují pro něj podle věty \ref{veta:optimalniTahy} optimální tah $T_{n-1}$ a plán $p_{n-1}$ takové, že
  \begin{equation*}
    p_n = T_{n-1}(p_{n-1})
  \end{equation*}
  a $p_{n-1}$ odbavuje stejně nebo o jeden méně incidentů na $I_{n-1}$ než $r$.
  Opět z věty \ref{veta:optimalniTahy} pro něj existují $p_{n-2}, T_{n-2} \colon p_{n-1} = T_{n-2}(p_{n-2})$, atd.\

  Takovou konstrukcí sestrojíme $p_{k}, T_{k}, \forall k \in \{ 0, \dots, n-1 \}$. 
  Plán $p_0$ je z věty \ref{veta:optimalniTahy} plán na prázdné množině odbavující buď jeden nebo nula incidentů, optimální v ceně.
  Pro prázdnou množinu incidentů jakýkoliv jiný plán než prázdný plán $p_{\emptyset}$ není optimální v ceně.
  Tudiž plán $p_0$ je prázdný plán.
  Tahy $T_k$ jsou optimální tahy, takže se jedná o hledanou posloupnost takovou, že
  \begin{equation*}
    p^* = (T_0 \circ T_1 \circ \dots \circ T_{n-1})(p_{\emptyset}).
  \end{equation*}
\end{dukaz}

\subsection{Rekurzivní prohledávání stromu optimálních tahů}

Věta \ref{veta:dosazitelnostOptimalnimiTahy} nám dává návod, jak plány $P_C$ z $p_{\emptyset}$ prohledávat optimálními tahy $T_1 \in T^*_1, \dots , T_{|I| - 1} \in T^*_{|I|-1}$.

\begin{algorithm}[H]
  \begin{algorithmic}[1]
  \Function{OptimalMovesSearch}{$p$, $I_k$, $h$, $P^*$}
    \If{$k = h$}
      \State $p^*$ \gets $\forall p \in P^*$
      \If{$q^{\text{Lex}}(p^*, I_k) = q^{\text{Lex}}(p, I_k)$}
        \State $P^*$ \gets $ P^* \cup p$
      \ElsIf{$q^{\text{Lex}}(p^*, I_k) < q^{\text{Lex}}(p)$}
        \State $P^*$ \gets $\{ p \}$
      \EndIf
      \State \Return $P^*$
    \EndIf
    \State $T^*_k$ \gets optimální tahy (viz definice \ref{df:optimalniTahy})
    \For{$T^* \in T^*_k$}
      \If{\text{\textbf{not}} $\text{Visited}[k, T^*(p)]$}
        \State $P^*$ \gets \text{OptimalMovesSearch($T^*(p)$, $I_{k+1}$, $h$, $P^*$)}
        \State $\text{Visited}[k, T^*(p)]$ \gets \text{true}
      \EndIf
    \EndFor
    \State \Return $P^*$
  \EndFunction
  \end{algorithmic}
  \caption{Rekurzivní prohledávání prostoru plánů optimálními tahy}
  \label{alg:rekProhPlanu}
\end{algorithm}

Pro zjištění všech optimálních plánu $P^*$ na množině incidentů $I$ algoritmus (viz algoritmus \ref{alg:rekProhPlanu}) zavoláme: $P^* = $ OptimalMovesSearch($p_{\emptyset}$, $I_1$, $|I|$, $\{ p_{\emptyset} \}$).

Pokud je v kroku 2 dosaženo hloubky $h$, algoritmus \ref{alg:rekProhPlanu} zkontroluje, zda je aktuální plán $p$ lepší než dosud nejlepší plán $p^* \in P^*$ podle účelové funkce $q^{\text{Lex}}$:
\begin{enumerate}
  \item Pokud je aktuální plán $p$ lepší, v kroku 7 se $P^*$ nahrádí množinou obsahující pouze aktuální plán $p$. 
  \item Pokud je stejně kvalitní, plán $p$ se v kroku 5 přidá do množiny $P^*$.
  \item Pokud je horší, plán $p$ není zajímavý a ignoruje se.
\end{enumerate}
Plán $p^*$ může být vybrán libovolně, protože všechny $p \in P^*$ mají stejné ohodnocení při účelové funkci $q^{\text{Lex}}$.
V kroku 9 se vrátí aktualizovaná množina doposud nejlepších nalezených plánů $P^*$.

Na každé hladině rekurze se v kroku 11 vygenerují optimální tahy pro aktuální množinu incidentů $I_k$, a pokud plán $T^*(p)$ vzniklý optimálním tahem $T^*$ nebyl navštíven,
rekurzivně se na něj algoritmus zavolá a aktualizuje se \textit{cache} navštívených stavů \textit{Visited}.

Tímto způsobem se systematicky prohledává celý prostor možných plánů a ukládají se všechny doposud nejlepší nalezené plány $P^*$.
Zároveň díky \textit{Visited} se zbytečně neprohledává podstrom ve stejné hloubce se stejným plánem vícekrát.

\begin{veta}[Korektnost a úplnost algoritmu]\label{}
  Algoritmus rekurzivního prohledávání prostoru plánů optimálními tahy (viz algoritmus \ref{alg:rekProhPlanu}) nalezne všechny optimální plány $P^* \subseteq P_C$ při účelové funkci $q^{\text{Lex}}$.
\end{veta}
\begin{dukaz}
  Z věty \ref{veta:dosazitelnostOptimalnimiTahy} víme, že $p^* \in P^*$ je dosažitelný nějakou posloupností optimálních tahů z prázdného plánu $p_{\emptyset}$. 
  V algoritmu v kroku 11 množina $T^*_k$ obsahuje všechny optimální tahy, které lze provést na plánu $p$ na množině $I_k$, počínaje prázdným plánem a prvním incidentem.
  V kroku 14 se rekurzivně zavoláme na každý $T^*(p), T^* \in T^*_k$, pokud již nebyl navštíven.
  Není důvod vícekrát prohledávát stejný podstrom, protože vrácená $P^*$ by byla stejná.
  Algoritmus tudiž prohledá každou posloupnost optimálních tahů, takže určitě i všechny takové, kterými se získá libovolný optimální plán $p \in P^*$ (plyne z věty \ref{veta:dosazitelnostOptimalnimiTahy}).
  Algoritmus je úplný.

  V krocích 3-8 vybíráme pouze plány optimální vůči $q^{\text{Lex}}$.
  Vybíráme tak ze všech plánů, které jsou dosažitelné nějakou posloupností optimálních tahů, ty optimální při $q^{\text{Lex}}$.
  Zároveň i \textit{cache} je korektně používaná, tudiž algoritmus je i korektní.
\end{dukaz}

Omezili jsme se na použití účelové funkce $q^{\text{Lex}}$, protože potřebujeme, aby optimální plán podle účelové funkce $q$ byl zároveň optimální v ceně.
Tento předpoklad optimální plán při $q^{\text{Lex}}$ splňuje (viz věta \ref{veta:lexJeOptVCene}).
Aby byl algoritmus korektní, mohli bychom použít jakoukoliv jinou účelovou funkci $q$, pro kterou optimální plán při $q$ je zároveň optimálním v ceně.
Podle věty \ref{veta:dosazitelnostOptimalnimiTahy} bude dosažitelný optimálními tahy, takže jej algoritmus navštíví.

Víme, že algoritmus je korektní. Ještě by nás zajímala jeho časová složitost.
K tomu si první odhadneme maximální počet optimálních tahů na hladině.
\begin{veta}[Odhad počtu optimálních tahů]\label{veta:pocetOptTahu}
  Nechť plán optimální v ceně $p \in P_C$ a nechť optimální tahy $T$, které lze provést na plánu $p$ na množině $I_k$.
  Pak
  \begin{equation*}
    1 \leq |T| \leq Z_n + 1.
  \end{equation*}
\end{veta}
\begin{dukaz}
  Optimální tahy jsou minimální alokace týmu, minimální prodloužení směny týmu a identita.
  První spočítejme, kolik je tahů minimální alokace týmu.
  Nechť $Z_1$ počet nenaalokovaných záchranných týmů.
  To jsou jediné týmy, které lze alokovat.
  Minimální alokace přiřazuje naalokovanému týmu $z$ nejkratší směnu se začátkem posunutým co nejpozději a případně alokuje záchranné vozidlo,
  aby byly odbavovány všechny incidenty $I_{k+1}$.
  Taková alokace ale existuje pro každý nenaalokovaný tým právě jedna.

  Zadruhé spočítejme, kolik je tahů minimální prodloužení týmu.
  Nechť $Z_2$ počet naalokovaných záchranných týmů.
  To jsou jediné týmy, kterým lze prodlužovat směna.
  Minimální prodloužení směny týmu $z$ směnu prodlouží o nejkratší možnou dobu a případně alokuje záchranné vozidlo,
  aby byly odbavovány všechny incidenty $I_{k+1}$.
  Takové prodloužení opět, tentokrát pro naalokované týmy, existuje právě jedno.

  Dohromady dostáváme: $Z_1 + Z_2 = Z_n$ a tah identita lze provést vždy a je jenom jeden, čili:
  \begin{equation*}
    1 \leq |T| \leq Z_n + 1.
  \end{equation*}
\end{dukaz}

Díky předchozí větě známe maximální počet optimálních tahů na každé hladině rekurze. Jak algoritmus probíhá,
tvoří \textit{strom rekurze} s větvícím faktorem úměrným počtu optimálních tahů a hloubkou stromu rovnou velikosti množiny incidentů $I$.
V následující větě spočítáme jeho velikost, což je klíčové pro zjištění složitosti algoritmu.
\begin{veta}[Velikost stromu rekurze]\label{veta:velikostStromuR}
Počet vrcholů stromu rekurze algoritmu je nanejvýš
  \begin{equation*}
    \frac{(Z_n + 1)^{|I| + 1}}{Z_n}
  \end{equation*}
\end{veta}
\begin{dukaz}
  Větvení stromu je dáno počtem optimálních tahů.
  Z věty \ref{veta:pocetOptTahu} jich je nanejvýš $Z_n + 1$.
  Hloubka stromu je $|I|$, proto
  počet vrcholů stromu činí nanejvýš
  \begin{equation*}
    \sum_{k=0}^{|I|} (Z_n + 1)^{k} = \frac{(Z_n + 1)^{|I| + 1}}{Z_n}.
  \end{equation*}
\end{dukaz}

Nyní máme všechny prostředky pro spočítání složitosti algoritmu.
\begin{veta}[Složitost alogirtmu rekurzivního prohledávání optimálních tahů]\label{veta:slozitostRek}
  Algoritmus rekurzivního prohledávání optimálních plánů běží v čase
  \begin{equation*}
    \mathcal{O}((Z_n + 1)^{|I| + 1}).
  \end{equation*}
\end{veta}
\begin{dukaz}
  Z věty \ref{veta:velikostStromuR} je počet vrcholů stromu optimálních tahů nanejvýš
  \begin{equation*}
    \frac{(Z_n + 1)^{|I| + 1}}{Z_n}.
  \end{equation*}
  V každém vrcholu procházíme všechny optimální tahy plánu, z věty \ref{veta:pocetOptTahu} jich je nanejvýš $Z_n + 1$.
\end{dukaz}

Nalezli jsme korektní algoritmus při účelové funkci $q^{\text{Lex}}$, který běží v exponenciálním čase podle počtu incidentů. 
Sice neběží v polynomiálním čase, ale stále se jedná o dramatické zlepšení oproti naivnímu řešením, jehož složitost je rovna velikosti množiny plánů (viz věta \ref{veta:PCvelikost}).

Strom také nemusíme prohledávat deterministicky, ale stochasticky tak, že v každé hladině rekurze budeme optimální tahy náhodně permutovat. Nemusíme ani zkoušet všechny optimální tahy,
ale pouze nějakou část. Hlavní výhodou algoritmu tak je schopnost plány prohledávat strukturovaně a navíc kvalita nalezeného řešení bude úměrná s délkou trvání algoritmu
-- čím déle bude běžet, tím více navštíví optimálních plánů v ceně a s větší šancí tak nalezne globální optimum.

\section{Metaheuristické metody}\label{kap:heuristiky}

V kapitole \ref{kap:NP} jsme diskutovali, do jaké třídy složitosti patří optimalizační úloha nalezení optimálního pohotovostního plánu.
Konkrétně jsme si ve větě \ref{veta:simulaceJakoCernaSkrinka} ukázali, že pokud na účelovou funkci budeme nahlížet jako na černou skříňku,
tak je optimalizační úlohu NP-těžká. V minulé kapitole jsme nalezli rekurzivní vztah, který nám umožnil se na
účelovou funkci nedívat jako na černou skříňku a nalezli jsme dramaticky lepší algoritmus \ref{alg:rekProhPlanu}, než naivní řešení (viz kapitola \ref{kap:naivniRes}).

V této kapitole jsou diskutovány metody, které na účelovou funkci pohlížejí jako na černou skříňku. 
Připouštíme tedy NP-těžkou složitost problému, ale ukáže se, že i tak budeme schopni docílit velmi kvalitních pohotovostních plánů.

\subsection{Popis}

\textit{Metaheuristické prohledávání prostoru konfigurací} patří mezi nejefektivnější způsoby řešení těžkých optimalizačních problémů,
jak diskrétních tak spojitých,
které nelze jednoduše vyřešit v polynomiálním čase.
Tyto metody prohledávání prostoru konfigurací koordinují interakce mezi lokálním a globálním optimalizováním,
aby byli schopny prohledávat lokálně optimální konfigurace, ale zároveň aby z nich mohli uniknout a prostor prohledávat robustně \cite{GlovKoch03}.

Často metaheuristiky při prohledávání využívají konceptu \textit{sousedství}.
Míra, do jaké jsou sousedství využívána, se liší podle konkrétního typu metody.
Některé metaheuristiky, jako například \textit{simulované žíhání} nebo \textit{tabu prohledávání}, využívají \textit{přípustné tahy},
pomocí kterých přecházejí z jednoho řešení na jiné v lokálním pohledu.
Zároveň dochází k výběru v lokálním pohledu horších konfigurací, aby se zajistila robustnost prohledávání
a metoda neuvázla pouze v lokálním optimu \cite{GlovKoch03}.

V případě metod, založených na \textit{populaci}, jako jsou například \textit{genetické algoritmy} \cite{genetic}, jsou sousedství implicitně definována
nahrazováním komponent jednoho řešení komponentami jiného řešení, různě zvolenými pravidly výměny.

Dalším zajímavým příkladem metaheurstické metody je \textit{optimalizování kolonií mravenců}, spadající do kategorie metaheuristik \textit{inteligence hejna} \cite{ACO}.
Sousedství jsou definována propojením cest a procházena pomocí simulování chodu mravenců, reprezentující nějakou kolektivní inteligenci.
Mravenci chodí po těchto cestičkách a vybírají si tak optimální konfigurace s pravděpodobností, jenž je uřčena feromony.

Existuje spoustu dalších různých metod, jako v poslední době populární \textit{hybridní metody},
které propojují více metaheuristických metod dohromady, s myšlenkou použít každou metaheuristiku co nejvhodněji,
případně i měnit různé metaheuristiky za běhu~\cite{HybridMeta}.

\subsection{Lokální prohledávání}\label{kap:localSearch}

Asi nejjednodušší metoda na prohledávání prostoru konfigurací je \textit{lokální prohledávání}.
Lokální prohledávání pouze lokálně prohledává prostor konfigurací od nějaké startovní konfigurace $x \in \mathcal{X}$. 
Prostor porhledává prostřednictvním sousedů $N(x)$, kde vždy vybere souseda s nejlepší hodnotou účelové funkce.~(\citet{HybridMeta}, str. 3).

Sousedy $N(p)$ zkonstruujeme implicitně pomocí tahů, což je standardní způsob konstrukce sousedů nějaké konfigurace (\citet{HybridMeta}, str. 3).
Sousední plány $N(p)$ plánu $p \in P_C$ lze definovat různě. 

My budeme od $p' \in N(p)$ vyžadovat alespoň následující:
\begin{enumerate}
  \item $\forall p \in P_C \colon N(p) \subseteq P_C$ \label{en:f}.
  \item $\forall p \in P_C, \exists(T_1, \dots, T_n) \colon (T_1 \circ \cdots \circ T_n)(p) = p^*$, kde $p^*$ je globálně optimální plán. \label{en:s}
  \item Pro všechny $p' \in N(p)$ pro dané $p$ platí, že jsou si plány $p$ a $p'$ podobné, čili z větší části mají naalokovaná stejná vozidla a týmy, se stejnými směnami. \label{en:t}
\end{enumerate}

Podmínka \ref{en:f} zakazuje navštěvování nedovolených plánů. Pro některé problémy je navštěvování nedovolených konfigurací žádoucí,
protože omezující podmínky můžou být příliš svazující (\citet{GlovKoch03}, str. 50-51).
To ale není náš případ, čili se můžeme omezit pouze na dovolené plány.

Podmínka  \ref{en:s} zajišťuje, že při prohledávání je vůbec možné globální optimum navštívit.

Podmínka \ref{en:t} vyžaduje, aby sousední plány sdíleli s původním plánem nějaké komponenty. 
Kdyby sousední plány nesplňovali tuto podmínku, prohledávání pomocí sousedů by se o moc nelišilo od náhodného
generování dovolených plánů, což není efektivní způsob prohledávání.

Pro představu, jedna z možných definic sousedství by mohla vypadat následovně.
Jelikož sousední plány definujeme pomocí tahů, stačí nadefinovat tahy:
  \begin{enumerate}
    \item alokování záchranného týmu a záchranného vozidla,
    \item dealokování záchranného týmu,
    \item dealokování záchranného vozidla,
    \item nejkratší prodloužení směny záchranného týmu,
    \item nejkratší zkrácení směny záchranného týmu,
    \item posun začátku směny záchranného týmu o nejkratší možnou dobu.
  \end{enumerate}

Je snadné ověřit, že sousedství definována implicitně těmito tahy splňují všechny podmínky.

Podívejme se, jak vypadá algoritmus lokálního prohledávání plánů pomocí sousedů.

\begin{algorithm}[H]
  \begin{algorithmic}[1]
    \Function{LocalSearch}{$p_{start}$, $I$}
    \State $p_{current}$ \gets $p_{start}$
    \While {true}
      \State $p^*$ \gets $p_{\emptyset}$ 
      \For {$p \in N(p_{current})$}
        \If {$q(p, I) > q(p^*, I)$}
          \State $p^*$ \gets $p$
        \EndIf
      \EndFor
      \If {$p^* = p_{\emptyset}$}
        \State \Return $p_{current}$
      \EndIf
      \State $p_{current}$ \gets $p^*$
    \EndWhile
  \EndFunction
  \end{algorithmic}
  \caption{Lokální prohledávání plánů pohotovostních služeb}
  \label{alg:hillclimb}
\end{algorithm}

Algoritmus lokálního prohledávání \ref{alg:hillclimb} v krocích 3 až 14 prohledává sousedy dokud není splněna podmínka v kroku 10.
Algoritmus v kroku 5 prohledává sousední plány splňující omezující podmínky $C$,
aktuálně prohledávaného plánu $p_{current}$, který je na začátku algoritmu v kroku 2 nastaven na $p_{start} \in P_C$.

V krocích 6 a 7, pokud má soused lepší hodnocení pří účelové funkci $q \in Q_I$, tak je aktuálně nejlepší soused $p^*$ změněn na souseda $p$.
Podmínka v kroku 10 kontroluje, zda existuje nějaký soused $p_{current}$, který má lepší hodnocení při $q$.
Pokud ne, algoritmus našel lokální maximum, tím je $p_{current}$, proto je vrácen v kroku 11.

V kroku 13 je $p_{current}$ nastaveno na nejlepší sousední plán.
Zřejmě lokální prohledávání nalezne nějaké lokální maximum, jaké konkrétně, závisí na startovním plánu $p_{start}$ a definici $N(p)$.

\begin{veta}[Časová složitost lokálního prohledávání]
  Nechť libovolný plán $p \in P_C$, pak lokální prohledávání běží v čase
  \begin{align*}
    \mathcal{O}(k \cdot |N(p)| \cdot |I| \cdot |Z|),
  \end{align*}
  kde $k$ je počet iterací, než lokální prohledávání nalezne nějaké lokální maximum.
\end{veta}
\begin{dukaz}
  Prohledáváme v každé iteraci všechny sousedy. Celkem je tudiž prohledáno $k \cdot |N(p)|$ plánů.
  Každý plán vyhodnocujeme při účelové funkci $q \in Q_I$. Vyhodnocení $q(p, I)$ je konstantní až na spuštění simulace. 
  Složitost simulace je $|I| \cdot |Z|$, protože pro každý incident je třeba nalézt nejvhodnější plán.
  Aktualizace stavů a spočítání doby odbdavování považujeme za konstantní.
\end{dukaz}

Pokud by $k$ i $|N(p)$| byli \uv{malé}, tak jsme získali velmi rychlý způsob, jak upravit libovolný plán, abychom dostali jeho \uv{nejlepší verzi}. 
Startovní plán definuje nějaký základ, který je následně doplňován nebo redukován o záchranné týmy nebo vozidla,
nebo jsou týmům postupně prodlužovány či zkracovány směny,
dokud jakákoliv změna už pouze nezhorší výslednou kvalitu. 
Jak konkrétně už záleží na konkrétní definici $N(p)$.

Velkou nevýhodou lokálního prohledávání je neschopnost umět nalézt kompromis mezi lokálním optimem a globálním optimem,
přičemž nalezené lokální optimum je v drtivé většině suboptimální (\citet{GlovKoch03}, str. 43).

\subsection{Tabu prohledávání}\label{kap:tabuSearch}

Tabu prohledávání stejně jako lokální prohledávání prohledává plány lokálně pomocí sousedů.
Tabu prohledávání se chová stejně jako lokální prohledávání, avšak narozdíl od lokálního prohledávání po nalezení lokálního optima v něm nezůstane,
ale umožní i navštívit souseda s horším hodnocením.
Aby se následně prohledávání nevrátilo zpět do stejného optima,
drží si seznam inverzních tahů posledních provedených tahů. Tomuto seznamu se říká \textit{tabu} a jedná se o tahy, které 
jsou při prohledávání zakázany.
Velikost seznamu tabu je takzvaná \textit{tabu tenura}, a jelikož se vždy ze seznamu odstraní nejposledněji provedený tah,
tak tabu tenura určuje po jaký počet kroků tabu prohledávání se tah uvažuje, že je zakázan. 
Ovšem vždy zakázat tahy z tabu může být příliš omezující, a výsledná nalezená řešení by mohla být suboptimální.
Z toho důvodu ještě tabu metoda využívá konceptu \textit{aspiračního kritéria}, které pokud je pro nějaký tah splěno,
tak je soused po provedení tohoto tahu uvažován i pokud je tah zakázan, čili i když se tah nachází v tabu \cite{tabu}.

Tabu prohledávání lze ukončit několika způsoby. Nejčastěji se prohledávání ukončuje, jakmile v iteraci už neexistují žádní zlepšující sousedé,
které získáme tahem, jenž není v tabu.~(\citet{GlovKoch03}, str. 41--49). 

\begin{algorithm}[H]
  \begin{algorithmic}[1]
    \Function{TabuSearch}{$p_{start}$, $I$, $t$}
    \State $p_{current}$ \gets $p_{start}$
    \State $p_{best}$ \gets $p_{start}$
    \State $tabu$ \gets \{\}
    \While {true}
      \State $p^*$ \gets $p_{\emptyset}$ 
      \For {$T \in \text{neighbours\_moves($p_{current}$)}$}
        \State $p$ \gets T($p_{current}$)
        \If {$q(p, I) > q(p^*, I)$ \textbf{and} ($T \notin tabu$ \textbf{or} $q(p, I) > q(p_{best}, I)$)}
          \State $p^*$ \gets $p$
        \EndIf
      \EndFor
      \If {$p^* = p_{\emptyset}$}
        \State \Return $p_{best}$
      \EndIf
      \State $p_{current}$ \gets $p^*$
      \If {$q(p_{current}, I) > q(p_{best}, I)$}
        \State $p_{best}$ \gets $p_{current}$
      \EndIf
      \State \text{AddFirst($tabu$, $T^{-1}$)}
      \If {$|tabu| > t$}
        \State \text{RemoveLast($tabu$)} 
      \EndIf
    \EndWhile
    \State \Return $p_{best}$
  \EndFunction
  \end{algorithmic}
  \caption{Tabu prohledávání plánů pohotovostních služeb}
  \label{alg:tabusearch}
\end{algorithm}

Algoritmus tabu prohledávání \ref{alg:tabusearch} si v krocích 1-5 inicializuje stav algoritmu. Tabu je ze začátku prázdné.
Podobně jako v lokálním prohledávání se prohledává prostor v krocích 5 až 24, dokud není splněna podmínka na řádku 13.
V krocích 7--12 se prohledávájí pomocí sousedních tahů sousedé aktuálně prohledávaného plánu $p_{current}$. 

Nejzajímavější je krok 9. Zde se prvně kontroluje stejně jako v lokálním prohledávání, zda je splěna nutná podmínka, jestli je vůbec třeba souseda $p$ uvažovat.
Druhá podmínka kontroluje, zda $p$ buď není v tabu, nebo je splněné aspirační kritérium.
Tah $T$, který je v tabu uvažujeme pouze pokud soused $T(p_{current})$ je doposavad nejoptimálnějším nalezeným plánem.
Takové aspirační kritérium je nejčastěji používané a obecně nejefektivněšjí aspirační kritérium~(\citet{GlovKoch03}, str. 47).

Podmínka v kroku 13 je totožná s podmínkou u lokálního prohledávání.
Pokud již neexistuje žádný zlepšující soused, který není v tabu nebo nesplňuje aspirační kritérium, tak vrátíme nejlepší nalezený plán $p_{best}$.
V kroku 17 aktualizujeme $p_{best}$, pokud jsme v aktuální iteraci nalezli kvalitnější plán.

V poslední řadě, v krocích 20--23 aktualizujeme tabu.
Do taba přidáváme inverzní tah, protože se ze souseda nechceme vrátit do původního plánu.
Pokud je tabu větší než dovoluje hyperparametr tabu tenura $t$, odebereme nejdříve přidaný tah.

Tabu prohledávání již narozdíl od lokálního prohledávání nezůstane uvězněné v lokálním optimu a díky tabu se do něj nevrátí a nezacyklí se.
Prohledá tak více plánů a bude vracet lepší řešení, než lokální prohledávání \cite{tabu}.

\subsection{Simulované žíhání}

Další variantou lokálního prohledávání je \textit{simulované žíhání}.
Podobně jako tabu prohledávání dovoluje navštěvovat lokálně neoptimální konfigurace, se snahou nalézt globální optimum.
Je to jedna z nejpopulárnějších technik na řešení těžkých optimalizačních úloh, především kombinatorických úloh \cite{siman}.

Simulované žíhání je inspirováno metalurgickým procesem žíhání, kdy je kov zahřán na vysokou teplotu
a následně ochlazován, za účelem odstranění vnitřních defektů.
Stejně jako ve fyzickém procesu žíhání, simulované žíhání si dřží teplotu.
Při vyšší teplotě je větší šance na navštěvování horších konfigurací a při nižší se pravděpodobnost snižuje, takže se navštěvují především lokálně optimální konfigurace.

Při postupném chlazení, tedy snižování teploty, se v průběhu běhu simulovaného žíhání postupně navštěvují horší konfigurace méně a optimální konfigurace více častěji.
Tento proces má zajistit ze začátku dostatečnou exploraci prostoru konfigurací, ale zároveň postupnou konvergenci k nějakému ideálně globálnímu řešení (\citet{GlovKoch03}, str. 1-2).

\begin{algorithm}[H]
  \caption{Simulované žíhání prohledávání plánů pohotovostní služby}
  \begin{algorithmic}[1]
    \Function{SimulatedAnnealing}{$p_{start}$, $t_{start}$, $M_k$, $t_{\text{cooling}}$, $t_{\text{final}}$}
    \State $p_{\text{current}} \gets p_{start}$
    \State $p_{\text{best}} \gets p_{start}$
    \State $t \gets t_{start}$
    \While{$t > t_{\text{final}}$}
      \For{$m \gets 1$ \textbf{to} $M_k$}
        \State $p \gets \text{zatím neprohledaný } \in N(p_{\text{current}})$
        \State $\Delta q \gets q(p_{\text{current}}, I) - q(p, I)$
        \If{$\Delta q \leq 0$}
          \State $p_{\text{current}} \gets p$
        \Else
          \State $p_{\text{current}} \gets p$ s pravděpodobností $\exp\left(-\frac{\Delta q}{t}\right)$
        \EndIf
        \If{$q(p, I) > q(p_{best}, I)$}
          \State $p_{best} \gets p$
        \EndIf
      \EndFor
      \State $t \gets t_{\text{cooling}}(t)$
    \EndWhile
    \State \Return $p_{\text{best}}$
    \EndFunction
  \end{algorithmic}
  \label{alg:siman}
\end{algorithm}

Algoritmus simulovaného žíhání \ref{alg:siman} si v krocích 2 až 4 inicializuje aktuálně prohledávaný plán $p_{\text{current}}$, nejlepší nalezený plán $p_{\text{best}}$ a akutální teplotu $t$.
Hlavní smyčka algoritmu v krocích 5--19 běží, dokud $t$ nepoklesne pod nejnižší dovolenou teplotu $t_{\text{final}}$.
V každé iteraci se provádí $M_k$ iterací, přičemž každá iterace se snaží najít lepší plán ze sousedních plánů $p$.
V kroku 8 se vypočítá rozdíl kvality $\Delta q$ aktuálně nejlepšího plánu a sousedního plánu.

Podle $\Delta q$ se rozhodne, zda přijmout sousední plán rovnou, nebo až v kroku 12.
V kroku 12 je $p$ přijato s pravděpodobností definovanou jako
\begin{align}\label{df:metropolis}
  \exp\left(-\frac{\Delta q}{t}\right).
\end{align}
Pravděpodobností funkce \ref{df:metropolis} je takzvané \textit{metropolis akceptační kritérium} \cite{Metropolis}, které modeluje
jak přechází termodynamický systém z aktuální konfigurace.
Určuje s jakou pravděpodobností v závislosti na aktuální teplotě $t$ je suboptimální soused uvažován.

V krocích 14--16 se standardně aktualizuje $p_{\text{best}}$, pokud $p$ má vyšší kvalitu než dosud nejlepší plán.
Po provedení $M_k$ iterací se v kroku 18 snižuje teplota $t$ pomocí ochlazovacího rozvrhu $t_{\text{cooling}}(t)$.
Jakmile aktuální teplota klesne pod $t_{\text{final}}$, algoritmus vrátí nejlepší nalezený plán $p_{\text{best}}$.

